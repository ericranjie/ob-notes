#

34r7hm4n 看雪学苑

 _2021年09月22日 18:04_

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)  

本文为看雪论坛精华文章  
看雪论坛作者ID：34r7hm4n

  

  

这篇文章的内容是我在研究自制操作系统时遇到的一个问题，即如何从16位实模式切换到32位保护模式，网上的资料比较少，讲得也不是很详细，在这跟大家分享一下我的解决方案。

  

**前置知识：**  

计算机是如何启动的？

_（http://www.ruanyifeng.com/blog/2013/02/booting.html）_

自制操作系统：引导扇区的实现

_（https://www.cnblogs.com/jiqingwu/p/os_boot_sector.html）_  

##   

##   

1

  

# **实模式和保护模式**

  

请参考：实模式和保护模式

_（https://blog.csdn.net/qq_37653144/article/details/82818191）_  

现代CPU有三种工作模式：实模式、保护模式和虚拟8086模式。CPU在加电后自动进入16位实模式，在主引导记录MBR加载特定的操作系统后，由操作系通经过一些设置切换到32位保护模式。

以WIN7为例，首先由MBR载入启动管理器bootmgr，在bootmgr中进行实模式到保护模式的切换，随后装载winload.exe，然后通过winload.exe加载Windows7内核，从而启动整个Windows7系统。

  

  

2

  

# **实模式到保护模式的切换**  

  

从实模式切换到保护模式大致可以分为以下几个步骤：

1、屏蔽中断

2、初始化全局描述符表（GDT）

3、将CR0寄存器最低位置1

4、执行远跳转

5、初始化段寄存器和栈指针

###   

### **1、屏蔽中断**

  

在16位实模式下的中断由BIOS处理，进入保护模式后，中断将交给中断描述符表IDT里规定的函数处理，在刚进入保护模式时IDTR寄存器的初始值为0，一旦发生中断（例如BIOS的时钟中断）就将导致CPU发生异常，所以需要首先屏蔽中断。

屏蔽中断可以使用cli指令：

```
cli
```

###   

### **2、初始化GDT**

  

屏蔽中断后我们就可以正式开始切换到保护模式的过程了。首先我们要完成GDT的初始化，这也是整个切换过程中最复杂的一步。

32位保护模式下的地址计算方式和16位实模式不一样，16位保护模式支持20位的寻址，物理地址等于段地址 * 16 + 偏移地址，其中段地址可以通过段寄存器获得，段地址和偏移地址都是16位。

在32位保护模式中，段与段之间是互相隔离的，当访问的地址超出段的界限时处理器就会阻止这种访问，因此每个段都需要有起始地址、范围、访问权限以及其他属性四个部分，这四个部分合在一起叫做段描述符（Segment Descriptor），总共需要8个字节来描述。但Intel为了保持向后兼容，将段寄存器仍然规定为16-bit，显然我们无法用16-bit的段寄存器来直接存储64-bit的段描述符。

解决的办法是将所有64-bit的段描述符放到一个数组中，将16-bit段寄存器的值作为下标来访问这个数组（以字节为单位），获取64-bit的段描述符，这个数组就叫做全局描述符表（Global Descriptor Table, GDT）。

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

上面这个就是64位段描述符的具体结构，包括段起始地址Base，限长Limit，Access Byte和Flags都是访问权限，结构如下：

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

Access Byte和Flags各项的解释，我直接复制OS Dev)了，更详细的解释可以参考《x86汇编语言：从实模式到保护模式》这本书的11.3节:

  

Pr: Present bit. This must be 1 for all valid selectors.

  

Privl: Privilege, 2 bits. Contains the ring level, 0 = highest (kernel), 3 = lowest (user applications).

  

S: Descriptor type. This bit should be set for code or data segments and should be cleared for system segments (eg. a Task State Segment)

  

Ex: Executable bit. If 1 code in this segment can be executed, ie. a code selector. If 0 it is a data selector.

  

DC: Direction bit/Conforming bit.

Direction bit for data selectors: Tells the direction. 0 the segment grows up. 1 the segment grows down, ie. the offset has to be greater than the limit.

Conforming bit for code selectors:

- If 1 code in this segment can be executed from an equal or lower privilege level. For example, code in ring 3 can far-jump to conforming code in a ring 2 segment. The privl-bits represent the highest privilege level that is allowed to execute the segment. For example, code in ring 0 cannot far-jump to a conforming code segment with privl==0x2, while code in ring 2 and 3 can. Note that the privilege level remains the same, ie. a far-jump form ring 3 to a privl==2-segment remains in ring 3 after the jump.
    
- If 0 code in this segment can only be executed from the ring set in privl.
    

  

RW: Readable bit/Writable bit.

Readable bit for code selectors: Whether read access for this segment is allowed. Write access is never allowed for code segments.

Writable bit for data selectors: Whether write access for this segment is allowed. Read access is always allowed for data segments.

  

Ac: Accessed bit. Just set to 0. The CPU sets this to 1 when the segment is accessed.

  

Gr: Granularity bit，粒度位，如果Gr置0则段界限limit是以字节为单位的，即段的大小为1B到1MB，如果Gr置0则以4KB为单位，段的大小从4KB到4GB。

  

Sz: Size bit，置0表示该段的偏移地址或操作数是16位的，比如说代码段该位置0，则取指令时会使用16位的指令指针寄存器IP来取指令，而栈段在进行栈操作时，会使用SP寄存器；置1表示使用的偏移地址或操作数是32位的，使用EIP和ESP寄存器。

  

Flags区域中空余的2位其中一位是给64位CPU使用的，这里我们置为0即可，另一位是留给用户软件使用的，CPU并不会使用。

GDT可以通过LGDT指令加载，加载后GDT的地址和大小被保存到了GDTR寄存器：

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

LGDT指令的操作数为6字节的数据，2个低位字节为GDT的大小减一，减一的原因是Size的最大值是65535，而GDT最多可以有65536字节（最多8192项）。4个高位字节为GDT的32位地址。

我们可以在汇编代码中定义GDT并用LGDT指令加载GDT，然后让MBR将我们这一段汇编代码加载到内存中的某个地址，然后跳转到这个地址执行，这样就完成了GDT的初始化。

接下来我们就来看一下在汇编代码中定义GDT的方法。Intel处理器规定GDT中的第一个描述符必须是空描述符，这是因为寄存器和内存单元的初始值一般都是0，如果程序设计有问题，就会无意中用全0的索引来选择描述符，gdt_null的作用就有点像C语言中的空指针。用汇编代码定义如下：

```
gdt_start:
```

  

dd 0定义了一个4字节的数据，两个dd 0正好是8字节，也就是一个描述符的大小。

接下来我们要定义代码段和数据段，为了方便，我们可以将代码段和数据段的起始地址都设为0，大小都设为4GB，这种设置方式也叫作平坦模式。现在的定义如下：

```
gdt_start:
```

  

此时代码段和数据段的访问权限和其他属性如下：

```
代码段：
```

```
数据段：
```

  

接着我们要定义栈段，由于我们的引导程序是加载到07c00h这个地址的，因此我们可以将07c00h以下的空间都作为栈空间，加入栈段后的定义如下：

```
gdt_start:
```

```
栈段：
```

  

接着我们定义6字节的GDT描述符：

```
; GDT descriptior
```

  

接着调用lgdt指令将GDT描述符加载到gdtr寄存器，整个GDT的初始化就算是完成了：

```
lgdt [gdt_descriptor]
```

###   

### **3、将CR0最低位置1**

  

CR0是系统内的32位控制寄存器之一，可以控制CPU的一些重要特性。其中最低位是保护允许位（Protected Mode Enable, PE），PE位置1后CPU进入保护模式（注意此时还是16位保护模式，不是32位保护模式），置0时则为实模式。现在我们要进入保护模式，即将CR0的最低位置1，汇编代码如下：

```
; 把 cr0 的最低位置为 1，开启保护模式
```

  

有关CR0其他位的功能以及其他控制寄存器可以查看Control register，这里不再赘述。

###   

### **4、执行远跳转**

  

将cr0最低位置1后，CPU就进入了保护模式，此时需要马上执行一条远跳转指令：

```
jmp 08h:PModeMain
```

  

这条指令有两个作用，第一个作用是将cs段寄存器的值修改为08h，切换到保护模式后，CPU寻址的方式就从实模式中的段地址 * 16 + 偏移地址改为了通过gdt寻址，所以这里的08h是段选择子而不是段地址，并且远跳转指令会自动将cs的值修改为对应的段选择子，这里是08h。

之前提到过，段描述符中的Sz位确定操作数的默认大小，将代码段寄存器切换到08h后，代码段描述符的Sz位为1，即32位模式，此时才真正进入了32位保护模式。

远跳转的另一个作用是清空CPU的流水线，流水线的作用在计组中有提到过，为了加速指令的执行，CPU在执行当前指令时会同时加载并解析接下来的一些指令，在进入保护模式之前，已经有许多指令进入了流水线，这些指令都是按16位模式处理的，而进入保护模式后的指令都是32位，所以这里通过一个远跳转来让CPU清空流水线。

切换到32位模式后，就应该执行32位的指令了，所以从PModeMain开始的指令都采用32位模式编译，通过[bits 32]这个标记实现：

```
[bits 32]
```

###   

### **5、初始化段寄存器和栈指针**

  

上一步中我们将代码段寄存器cs初始化成了0x08，现在我们还需要初始化其他的段寄存器如数据段寄存器ds，拓展段寄存器es，栈段ss以及fs，gs两个由操作系统使用的段。

另外我们还需要初始化栈指针ebp和esp，代码如下：

```
[bits 32]
```

  

此时我们就可以开始执行32位保护模式下的代码了。

##   

##   

3

  

# **测试：32位保护模式下的打印**

  

接下来我们要实现的是32位保护模式下的打印功能，测试我们是否已经成功进入32位保护模式了。

在32位保护模式中我们无法使用实模式下的BIOS中断指令进行打印，但是天无绝人之路，我们仍然可以通过直接修改显存来进行打印。

显卡包括显存本身是外围设备，但CPU很友好的把显存映射到了0x8B000这个物理地址，因此我们可以直接通过mov指令来访问显存。在文本模式下，被打印的字符在显存中总共占2个字节，第一个字节是字符的ASCII码，第二个字节是字符的颜色属性，这里与BIOS中int 10调用的颜色属性是一样的：

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

打印字符串的代码我们可以写成一个函数，具体的内容大家看下面的代码和注释：

```
; 打印字符串
```

  

函数调用：

```
PModeTest:
```

  

效果如下：

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

  

##   

4

  

# **完整代码**

  

完整的代码，需要在引导程序中加载这段代码到正确的位置，这里是09000h，或者直接把org 09000h改成org 07c00h，把这段代码写到主引导扇区：

```
org 09000h
```

##   

  

5

  

# **A20地址线**

  

A20的“A”是“Address”的首字符，A20也就是第21根地址线的意思。这里涉及到一个历史遗留问题，但如果我们是在Bochs这样的模拟器上进行调试的话没有影响，所以我把这个问题放到了最后来讲。

在8086处理器上只有20根地址线，最多支持20位的地址，因此每当物理地址达到最高端0xFFFFF时，再加上1又会绕回最低端0x00000。为了兼容地址回绕这个特性，后来生产的CPU都会默认关闭第21根地址线，需要操作系统在进入保护模式时手动开启。

不过某些BIOS，包括模拟器（qemu, Bochs等）会默认帮我们打开A20地址线，所以我们不需要手动开启了，我们可以用一段程序来测试A20地址线是否打开：

```
PModeTest:
```

  

测试结果，可以看到在Bochs中A20地址线确实是默认开启的：

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

从80486处理器开始，0x92端口的第2位用来控制A20地址线，将0x92端口的第2位置1即可开启A20地址线，如果要手动开启A20地址线的话，可以使用以下代码：

```
in al, 92h
```

  

  

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E) 

  

**看雪ID：34r7hm4n**

https://bbs.pediy.com/user-home-910514.htm

*本文由看雪论坛 34r7hm4n 原创，转载请注明来自看雪社区

  

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

官网：https://www.bagevent.com/event/6334937

  

[![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458387399&idx=2&sn=38495add2a3a3677b2c436581c07e432&scene=21#wechat_redirect)

  

**#** **往期推荐**

1. [large chunk分配过程调试](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458392830&idx=2&sn=3014a94f36cdb65339347b3a76345cd9&chksm=b18f287486f8a162ab0cd3eeb553aea09647f1ef73362d238f90b42eb9440cf3589bc40a7e38&scene=21#wechat_redirect)  

2. [混淆后OKHTTP框架的通用抓包方案探索](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458392678&idx=1&sn=7572d38e20a9f359bba0c8aa8e4965b4&chksm=b18f28ec86f8a1fa2541609df9252d10383a9c589a092eba088d277c89b4934c59e27b5ab76f&scene=21#wechat_redirect)

3.[CVE-2017-17215(华为HG532远程命令执行漏洞)复现学习](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458392581&idx=1&sn=c9ad7d416aacce9c58ec4a56e4027827&chksm=b18f288f86f8a199c2ca7072787d95573ecb890668d1c119a808033a017b45659e539242a81f&scene=21#wechat_redirect)

4. [高Glibc版本下的堆骚操作解析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458392560&idx=1&sn=73533c60d701ad5816545520bc889135&chksm=b18f277a86f8ae6ce880fd532b70bbbb70180859299f7476bd1d3033a43ea7e0b3fb6709c460&scene=21#wechat_redirect)

5.[新人PWN堆Heap总结off-by-null专场](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458392540&idx=1&sn=75525c0ee1d799edbf118b4e19b81e3a&chksm=b18f275686f8ae40bacfec040a64b645227ce1f5554cdc5e95c337b63573d1ec67a57bebec01&scene=21#wechat_redirect)

6. [CVE-2012-3569 VMware OVF Tool格式化字符串漏洞分析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458392532&idx=1&sn=009b3954d88c8732df14e2d442e6cf04&chksm=b18f275e86f8ae48ec217fc9b28c98cdcfa94822de52fd359c75d81de835ce23605f46fcdf79&scene=21#wechat_redirect)

  

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

公众号ID：ikanxue  

官方微博：看雪安全

商务合作：wsc@kanxue.com

  

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**球分享**

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**球点赞**

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

**球在看**

  

  

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

点击“阅读原文”，了解更多！

阅读原文

阅读 1495

​

写留言

**留言 5**

- 苞苞大帝
    
    2021年9月22日
    
    赞1
    
    实模式和保护模式在看汇编书籍的时候老是提到，后来也是看了那本书。尼玛太复杂了。
    
- e^(iα)=cosα+isinα
    
    2021年10月19日
    
    赞
    
    可以看看linux0.11和xv6启动阶段都差不多
    
- 玉苏普
    
    2021年9月23日
    
    赞
    
    能做自己的简单一点儿的操作系统吗
    
- 不忘初心
    
    2021年9月23日
    
    赞
    
    很有意义 可惜我看不懂
    
- 王大山
    
    2021年9月22日
    
    赞
    
    初始化GDT 一节里，gr的解释写了两个置0
    

已无更多数据

[](javacript:;)

![](http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EGLfh77kFmnicd9WOic2ibvhCibFdB4bL4srJCgo2wnvdoXLxpIvAkfCmmcptXZB0qKWMoIP8iaibYN2FA/300?wx_fmt=png&wxfrom=18)

看雪学苑

716

5

写留言

**留言 5**

- 苞苞大帝
    
    2021年9月22日
    
    赞1
    
    实模式和保护模式在看汇编书籍的时候老是提到，后来也是看了那本书。尼玛太复杂了。
    
- e^(iα)=cosα+isinα
    
    2021年10月19日
    
    赞
    
    可以看看linux0.11和xv6启动阶段都差不多
    
- 玉苏普
    
    2021年9月23日
    
    赞
    
    能做自己的简单一点儿的操作系统吗
    
- 不忘初心
    
    2021年9月23日
    
    赞
    
    很有意义 可惜我看不懂
    
- 王大山
    
    2021年9月22日
    
    赞
    
    初始化GDT 一节里，gr的解释写了两个置0
    

已无更多数据