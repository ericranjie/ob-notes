[![LWN.net 徽标](https://static.lwn.net/images/logo/barepenguin-70.png)LWN\
.net消息来源](https://lwn.net/)[](https://lwn.net/)

- [**内容**](https://lwn.net/Articles/980654/#t)

  - [每周版](https://lwn.net/current/)
  - [档案](https://lwn.net/Archives/)
  - [搜索](https://lwn.net/Search/)
  - [核心](https://lwn.net/Kernel/)
  - [安全](https://lwn.net/Security/)
  - [活动日历](https://lwn.net/Calendar/)
  - [未读评论](https://lwn.net/Comments/unread)

  ______________________________________________________________________

  - [LWN 常见问题解答](https://lwn.net/op/FAQ.lwn)
  - [为我们写信](https://lwn.net/op/AuthorGuide.lwn)

- [**版**](https://lwn.net/Articles/980654/#t)

  - [⇒首页](https://lwn.net/Articles/980654/)
  - [简要项目](https://lwn.net/Articles/980656/)
  - [公告](https://lwn.net/Articles/980657/)
  - [一个大页面](https://lwn.net/Articles/980654/bigpage)
  - [上周](https://lwn.net/Articles/979852/)
  - [下一周](https://lwn.net/Articles/981628/)

**用户：**  **密码：**

|

|

# LWN.net 2024 年 7 月 11 日周刊

### [欢迎阅读 2024 年 7 月 11 日 LWN.net 周刊](https://lwn.net/Articles/981575/)

此版本包含以下特色内容：

- [C++26 中的新特性](https://lwn.net/Articles/979870/)：了解下一个主要版本 C++ 中可能出现的一些特性。

- [Sxmo：以文本为中心的移动用户界面](https://lwn.net/Articles/981320/)：一种不同的交互式移动应用程序方法。

- [再次尝试在 vDSO 中使用 getrandom()](https://lwn.net/Articles/980447/)：持续努力为用户空间提供快速、安全的随机数据。

- [内核中的卸载友好型网络加密](https://lwn.net/Articles/980430/)：看一下 PSP 安全协议。

- LSFMM+BPF 2024 的另外两份报告：

  - [针对 tree-in-dcache 文件系统的新 API](https://lwn.net/Articles/980558/)：将整个树存储在目录条目缓存中的文件系统数量激增，但无法很好地处理边缘情况；新的 API 将尝试解决其中的一些问题。
  - [改进伪文件系统](https://lwn.net/Articles/981155/)：伪（或虚拟）文件系统存在大量问题，部分原因是对于想要创建伪文件系统的内核开发人员来说，缺乏可用的指导；如何才能改进这一点？

- [使用 nmbl 为引导加载程序提供引导](https://lwn.net/Articles/979789/)：直接引导到内核并切断引导加载程序中间人。

本周版本还包括以下内页：

- [简要新闻](https://lwn.net/Articles/980656/)：来自整个社区的简要新闻。
- [公告](https://lwn.net/Articles/980657/)：新闻通讯、会议、安全更新、补丁等。

请欣赏本周的版本，并且一如既往地感谢您对 LWN.net 的支持。

[评论 (未发表)](https://lwn.net/Articles/981575/#Comments)

### [C++26 中的新功能](https://lwn.net/Articles/979870/)

作者：**Daroc Alden**\
2024 年 7 月 5 日

ISO 每三年 发布一次新的C++语言标准；现在距离C++23定稿已经过去了一年多，我们对[C++26](https://en.cppreference.com/w/cpp/26) [可以采用](https://en.cppreference.com/w/cpp/26) 哪些特性有了很好的了解 ——尽管提案仍可在 2025 年 1 月之前提交。特别值得注意的是增加了对 [风险指针](https://en.wikipedia.org/wiki/Hazard_pointer)和 [用户空间读取-复制-更新](https://lwn.net/Articles/573424/)(RCU) 的支持。尽管C++26尚未成为标准，但许多提议的特性已经可以在 GCC 或 Clang 中试验。

#### 新的线程库

风险指针是一种用于构建无锁并发代码的技术。在具有风险指针的系统中，每个线程都会保留一个当前正在访问的共享对象列表。其他线程可以使用该信息来避免修改或释放仍在使用的对象。

在 [提议的C++库](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2530r3.pdf)中，想要释放潜在共享对象的线程会“退出”该对象，将回收该对象的责任转交给库。退出对象是原子操作，因此对象退出后就不会再有新的读取者。当对象退出时，库会检查是否有任何现有风险指针引用它。如果仍然引用它，则会将其添加到一组退出对象中，并定期重新检查这些对象（当另一个对象退出时，而不是按计时器检查）。一旦没有风险指针引用该对象，就会释放该对象。

[提议的接口](https://en.cppreference.com/w/cpp/header/hazard_pointer) 要求 任何受风险指针保护的类都是hazard_pointer_obj_base的子类。然后，用户可以调用 make_hazard_pointer()来创建风险指针。调用 返回的风险指针的protect()方法保护带有指针的对象，线程可以正常使用该对象。想要退出对象的线程将调用 object->retire()，将其交给库。总之，提议的 API 将像这样使用：

```
// 向库注册一个新的（空的）风险指针
危险指针 hp = make_hazard_pointer();
// 获取需要保护的对象的指针
const atomic<T*>& object = ...;
// 将指针放入 hazard_pointer 中以保护它
T* normal_pointer = hp.保护（对象）；
... // 使用 normal_pointer 执行操作
// 完成后从 hazard_pointer 中删除对象，
// 或者让 RAII 清理 hazard_pointer。
hp.重置保护（正常指针）；
// 同时，另一个线程可以调用
对象->退出()
```

但是，风险指针并不是唯一的新增功能。用户空间 RCU 支持也被 [提议纳入其中](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2545r1.pdf)。RCU 是 Linux 内核中 [广泛使用的](https://lwn.net/Articles/262464/)一种技术。对受 RCU 保护的对象进行访问是通过指针完成的；当线程想要更​​改对象时，它首先会制作一个单独的副本，然后编辑该副本。最后，线程原子地交换指针以指向新副本。使用比较和交换指令可让线程知道，如果它碰巧与另一个写入器争用，则需要重试。该库还会跟踪一些信息，以确定所有读取器何时完成对旧版本的对象的读取，从而允许写入线程释放它。具体细节可能因实现而异，因此提议的 API 并不要求采用特定方法来确保读取器已完成。

与风险指针提案一样，新的 RCU 库定义了一个rcu_obj_base类，受 RCU 保护的对象可以从该类继承。与风险指针不同，这种继承不是必需的； [rcu_retire](https://en.cppreference.com/w/cpp/header/rcu) 可用于不是该类后代的对象。

这两个库都已经有可用的参考实现。引用了几个用户空间 RCU 库，但两个提案都将 Apache-2.0 许可的[folly](https://github.com/facebook/folly) 库列为主要参考实现。如果被接受，这些功能将成为C++标准库的一部分。

#### 其他库更改

还有大量关于在标准库中包含较小或不太重要的功能的提案。C ++26可能会看到一个 提供breakpoint()函数的[调试](https://en.cppreference.com/w/cpp/header/debugging)标头、一个 包含 [BLAS](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) 功能的 [线性代数](https://en.cppreference.com/w/cpp/header/linalg)标头，以及一个 允许用户访问 [IANA 字符集注册表](https://www.iana.org/assignments/character-sets/character-sets.xhtml)（可在互联网上使用的字符集的官方列表）的文本 [编码标头。](https://en.cppreference.com/w/cpp/header/text_encoding)[](https://en.cppreference.com/w/cpp/header/linalg)[](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms)[](https://en.cppreference.com/w/cpp/header/text_encoding)[](https://www.iana.org/assignments/character-sets/character-sets.xhtml)

标准库的其他部分有大量的修复和更新，包括对 charconv函数的[更改](https://wg21.link/P2497R0)、对格式和打印的几处更新、 编译时的 [稳定排序](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)、使更多类型可用作映射键的更改，以及对几处弃用项目的删除。[](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)

#### 新的核心语言变化

新标准还计划对语言本身进行更改。有些变化相对较小；C++26可能会包含 对属性可忽略含义的 [澄清](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2552r2.pdf)，以及对描述当某些初始化器使用 [括号省略功能时如何确定数组长度的措辞](https://en.cppreference.com/w/cpp/language/aggregate_initialization) [的更改](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3106r1.html)。还有一些针对字符串文字的小修复，例如 在词法分析期间 [定义](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2621r2.pdf)以前未定义的行为（包括指定未终止的字符串文字格式不正确）， [指定](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1854r4.pdf)字符串文字中不允许使用源文件编码中无法编码的字符，并 [澄清](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2361r6.pdf)何时应由编译器评估字符串文字。[](https://en.cppreference.com/w/cpp/language/aggregate_initialization)[](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2621r2.pdf)[](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1854r4.pdf)[](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2361r6.pdf)

但即将发生的大部分变化都更加有趣。一项 [提议](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2809r3.html)是将一些无限循环转变为已定义的行为。这对于某些故意使用无限循环作为暂停线程方式的低级代码的正确性尤其重要。无限循环最初被设定为未定义行为，以便允许优化编译器假设程序向前发展；一般来说，确定循环条件是否变为假等同于暂停问题。如果允许编译器假设循环最终将暂停，它就可以使用该信息进行原本不可能实现的优化。

然而， C 和 C++对于实现如何处理无限循环的要求略有不同。C 对具有常量控制表达式的循环有明确的例外。因此，自 C11 以来，这两个循环就有了显著的不同：

```
int 条件 = ...;
while (条件) {
    // ...
}
while (真) {
    如果（！条件）
        休息;
    // ...
}
```

前一个循环可以假设最终会终止，但后一个循环不能。相比之下，C++11允许编译器假设两个循环最终都必须终止。该提案将改变这些规则，以便“琐碎的”无限循环（具有空体的循环）不会被视为未定义的行为。这与 C 所规定的不同，但它将允许实际上打算让 CPU 在空循环中旋转的低级代码。

另一项变化是 允许在[constexpr中将](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf)[void\*](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf) [转换为其他类型](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf)，这是 C++ 的编译时代码执行机制。随着时间的推移，该语言一直在慢慢扩展编译时可能实现的功能，主要是以库更改的形式将函数标记为constexpr 。但constexpr代码仍然存在一些基本限制，其中许多限制与内存有关。允许constexpr代码使用 void 指针是放松这些限制的又一步。

这并不是唯一的编译时改进 — 有提案要求 [static_assert ()接受用户提供的消息](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r3.pdf)，以及 [向= delete语法](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2573r2.html)添加消息（这允许程序员抑制编译器通常提供的方法的生成，例如复制构造函数）。这两项更改都可以使传达编译时检查背后的原因变得更容易，并使编写可维护的代码变得更容易。还有 [一项提案](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2748r5.html)要求将返回的 glvalue 绑定到格式错误的临时值。glvalue 是任何表达式，其求值确定对象或函数的身份 — “广义左值”，可以为其分配某些内容。换句话说，这样的代码将不再被接受：

```
const std::string_view& getString() {
    静态 std::string s；
    返回 s；
}
```

如果getString()直接返回std::string，它将有效（并且仍然有效）。问题在于std::string_view&是对std::string_view的非拥有引用。当返回值时，底层 std::string_view被释放，引用变为悬空。Rust 等语言使用所有权系统解决了这个问题；C++26不会走得那么远——仍然可以编写一个返回悬空引用的函数。但如果不小心这样做，就会变得有点困难，因为对临时值的引用（例如对 std::string_view& 的隐式转换）会被编译器检测到。

#### 模板改进

C++26还计划对模板系统进行一些改进。在C++中，当模板采用名称前带有“...”的参数时，编译器会创建一个特殊的结构，该结构包含多个参数，称为“pack”。 [一个小提案](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2662r3.pdf)将允许\[\]运算符索引模板中的包。为了将其与普通索引操作区分开来，该提案提供了用于访问包元素的新语法：name...\[\]。例如：

```
模板 <类型名称...T>
constexpr auto first_plus_last(T...值) -> T...[0] {
    返回 T...[0](值...[0] + 值...[sizeof...(值)-1]);
}
```

包还可以用在更多的地方，只需进行 [一个更改，](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r3.html)就可以将它们用在类的友元声明中。这个更改可能很有用，因为它允许程序员使用模板来实现 [密码惯用法](https://arne-mertz.de/2016/10/passkey-idiom/)，这是一种仅向特定类公开给定方法的技术。

迄今为止，对语言本身的最新提议更改包括对变量绑定的两项更改： [允许结构化绑定上的属性](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0609r3.pdf)，并 [允许绑定中的_丢弃值](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf)。最后，对编译器初始化模板参数的方式进行了 [一项不明显的更改](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2308r1.html)，并对 [花括号初始化器进行了更改](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r2.html)，使其更加高效。

当人们考虑语言的发展时，C++可能不是人们首先考虑的语言，但它在每个版本中仍然有几项重要的改进。如果没有出现问题，这些变化很可能会在明年的C++26标准化会议上被接受。与此同时，仍然有一个开放的窗口来反思这些变化并提出更多建议。

\[感谢 Alison Chaiken 建议介绍用户空间 RCU 并促成了本文的撰写。\]

[评论 (已发布 134 条)](https://lwn.net/Articles/979870/#Comments)

### [Sxmo：以文本为中心的移动用户界面](https://lwn.net/Articles/981320/)

2024 年 7 月 10 日

本文由 Koen Vervloesem 撰写

[Sxmo](https://sxmo.org/)是“Simple X Mobile”的缩写，其网站将其描述为“ Linux 移动设备的极简环境”；它提供了一个菜单驱动的界面，可以通过手机的硬件按钮进行控制。Sxmo 允许用户从文本编辑器发送短信，并且完全可以使用 shell 脚本进行自定义。这种独特的移动用户界面与主流方法有很大不同——但它很有效。

[![[Sxmo主菜单]](https://static.lwn.net/images/2024/sxmo-menu-sm.png "Sxmo 主菜单")](https://lwn.net/Articles/981347/)

[虽然Phosh](https://phosh.mobi/)、[KDE ​​Plasma Mobile](https://plasma-mobile.org/)和[Lomiri](https://lomiri.com/)等移动用户界面之间存在一些差异，但它们都植根于相同的理念。它们以基于触摸的交互为中心，并通过图标显示应用程序，这种方法受到桌面用户界面传统点击模式的影响。然而，在桌面上，以文本为中心的方法以键盘输入和遵循 Unix 理念的终端程序为中心，在高级用户中仍然很受欢迎。Sxmo 旨在为移动设备提供这样的环境。

Sxmo 有两种版本：Xorg 或 Wayland。Xorg 版本基于[suckless](https://suckless.org/)项目 的几个工具[分支](https://sr.ht/~mil/sxmo/sources)，该项目“注重简洁、清晰和节俭”。这包括动态窗口管理器[dwm](https://dwm.suckless.org/)、菜单系统[dmenu](https://tools.suckless.org/dmenu/)和简单的终端仿真器[st。Wayland](https://st.suckless.org/)版本使用了一些受 Xorg 对应版本启发的工具，包括平铺 Wayland 合成器[Sway](https://swaywm.org/)、菜单系统[bemenu](https://github.com/Cloudef/bemenu?tab=readme-ov-file#bemenu)和终端仿真器[foot](https://codeberg.org/dnkl/foot)。实际上，这两个版本的工作原理类似，配置上有一些细微的底层差异。[](https://suckless.org/)[](https://dwm.suckless.org/)[](https://tools.suckless.org/dmenu/)[](https://st.suckless.org/)[](https://swaywm.org/)[](https://github.com/Cloudef/bemenu?tab=readme-ov-file#bemenu)[](https://codeberg.org/dnkl/foot)

Sxmo 在移动设备的[postmarketOS](https://postmarketos.org/) Linux 发行版上得到了最佳支持（之前[在此处介绍过](https://lwn.net/Articles/979522/)）。可以在发行版的[下载](https://postmarketos.org/download/)页面上找到针对各种设备的带有 Sxmo 的 postmarketOS 预构建映像。或者，可以通过运行 pmbootstrap init并选择sxmo-de-sway（用于 Wayland 版本）或sxmo-de-dwm（用于 Xorg 版本）作为界面来构建自定义映像。我通过安装定制的 postmarketOS 映像测试了 Sxmo 的 Wayland 版本。

#### 菜单驱动界面

由于 Sxmo 的交互方式与其他移动界面有很大不同，因此必须阅读其[用户指南](https://man.sr.ht/~anjan/sxmo-docs-stable/USERGUIDE.md)，尤其是要了解手机硬件按钮背后的操作。大多数手机侧面有三个按钮：音量调高、音量调低和电源。对于每个按钮，Sxmo 都会根据您点击按钮一次、两次或三次来触发操作；可以使用长按来代替点击三次。这样，用户只需使用拇指，就可以使用硬件按钮启动九种不同的操作。触摸式输入也有效。

Sxmo 的主屏幕只是一个显示当前日期和时间的背景图像，顶部有一个状态栏，其中包含工作区编号（最初只有一个），旁边是移动网络、WiFi 连接、电池、音量、锁定状态和时间的状态图标。当用户点击调高音量按钮或从屏幕顶部向下滑动时，全局系统菜单会打开。在菜单中，硬件按钮表现出不同的行为：调高音量按钮导航到上一个项目，而调低音量按钮前进到下一个项目。电源按钮选择当前项目。点击触摸屏上的项目也会选择它。

全局系统菜单允许访问各种脚本和应用程序。选择几个菜单项后，会在终端窗口中打开应用程序。例如，扫描 WiFi 网络会启动 nmcli d wifi list命令。配置手机（在配置子菜单下）可以设置亮度、启用或禁用触摸、手势和蓝牙，以及升级软件包等。

#### 短信和电话

[![[Sxmo接听电话]](https://static.lwn.net/images/2024/sxmo-call-sm.png "Sxmo接听电话")](https://lwn.net/Articles/981349/)

发送短信需要先输入电话号码或从联系人列表中选择一个人。然后打开类似 Vim 的文本编辑器[vis](https://github.com/martanne/vis)来撰写消息。用户退出编辑器并确认后，消息即发送。收到的短信会短暂显示在主屏幕上；也可以稍后从全局系统菜单（包含在通知菜单项中）和文本子菜单中阅读。收到新短信后，手机的 LED 会发出绿光，振动马达会瞬间触发。

呼叫使用类似的以文本为中心的流程。要拨打新电话，请打开全局系统菜单中的拨号器子菜单，然后输入电话号码或从联系人列表中选择一个条目。选择号码后，Sxmo 开始呼叫，一旦呼叫接通，就会出现一个菜单，其中包含挂断电话、管理音频路由等选项。来电会触发手机的绿色 LED 和振动马达，并会出现一个菜单，让用户可以接受或拒绝来电。

#### 移动端

当没有菜单处于活动状态时，单击音量减小按钮可显示或隐藏屏幕底部的虚拟键盘。此操作也可以通过从屏幕底部上下滑动来执行。单击音量增大按钮可启动特定于应用程序的上下文菜单，用于受支持应用程序的当前焦点窗口。三次点击或按住电源按钮可打开终端仿真器。三次点击（或按住）音量减小按钮可终止当前焦点窗口。

尽管在主要基于触摸的设备上操作终端应用程序似乎不太合适，但 Sxmo 定义了一些单指滑动手势来简化体验。例如，沿底部边缘从左向右滑动会向应用程序发送 Return 键。同样，沿底部从右向左滑动会发送 Backspace 键。沿右边缘从上向下滑动会发送向下箭头键，而沿右边缘从下向上滑动会发送向上箭头键。从右向左滑动到左边缘会发送左箭头键，而从左向右滑动到右边缘会发送右箭头键。这些手势允许用户滚动浏览 shell 历史记录和当前命令，而无需打开虚拟键盘并占用宝贵的屏幕空间。但是，虚拟键盘不支持滑动输入。

#### 纯文本文件和 Shell 脚本

Sxmo 的配置完全基于纯文本文件。例如，联系人详细信息存储在 ~/.config/sxmo/contacts.tsv中一个制表符分隔的文件中。此文件有两列：第一列是电话号码，第二列是联系人姓名。可以通过手动编辑文件或从全局系统菜单中的联系人条目添加联系人。同样， ~/.config/sxmo/block.tsv文件列出了用户希望阻止的电话号码和相应的联系人姓名。

Sxmo 的行为在~/.config/sxmo/profile文件 中定义，也定义在数十个钩子中，这些钩子是具有特定名称的 shell 脚本。例如，当电话接到来电时， 将执行/usr/share/sxmo/default_hooks/sxmo_hook_ring.sh中的 shell 脚本，并将第一个参数 ( $1 ) 设置为联系人姓名或来电号码。如果用户想要更改默认行为，可以通过~/.config/sxmo/hooks/sxmo_hook_ring.sh文件覆盖此脚本。用户脚本还可以添加到全局系统菜单中以实现自定义功能。postmarketOS wiki 为 Sxmo 提供了一个[技巧和窍门](https://wiki.postmarketos.org/wiki/Sxmo/Tips_and_Tricks)页面，其中包含一些有用的建议和配置片段。若要更深入地了解内部情况，Sxmo 的[系统指南](https://man.sr.ht/~anjan/sxmo-docs/SYSTEMGUIDE.md) 提供了极好的信息来源。

#### 为 Sxmo 做贡献

Sxmo 的大部分核心功能都是基于 shell 脚本构建的。虽然这允许完全自定义，但它需要一些 Linux 和 shell 脚本知识。开发人员积极邀请[贡献](https://man.sr.ht/~anjan/sxmo-docs-stable/CONTRIBUTING.md)，尤其是[设备配置文件](https://git.sr.ht/~mil/sxmo-utils/tree/master/item/scripts/deviceprofiles/README.md)，这些是 Sxmo 早期加载的 shell 脚本，用于设置一些属性，确保设备与 Sxmo 配合良好。

Sxmo 最初是为 PinePhone 设计的。同时，还增加了对其他一些设备的支持，包括 Librem 5 和 Fairphone 4，以及配备物理键盘的 15 年前的诺基亚 N900 和 Kobo Clara HD 电子阅读器。尝试在未受支持的设备上运行 Sxmo 的用户可以在上面链接的 sxmo-utils 存储库中找到一些创建设备配置文件的说明。结果是一个 shell 脚本，它导出触摸屏设备、显示输出、屏幕比例、按钮等的一些环境变量。

在过去的两年中，Sxmo 已经发布了八个[版本](https://lists.sr.ht/~mil/sxmo-announce/)，去年的更新速度有所放缓。最新的是6 月 3 日发布的[Sxmo 1.16.1](https://lists.sr.ht/~mil/sxmo-announce/%3CD1QCSDN7DYIB.2R4TBAG9SVKDQ@willowbarraco.fr%3E) ，这是一个小版本。它对挂起功能的控制进行了一些细微的改进，并为 PINE64 的 PineTab 2 平板电脑和小米的 Redmi Note 4 手机提供了初始设备配置文件。有一个跟踪错误和功能改进的[票证列表](https://todo.sr.ht/~mil/sxmo-tickets)，但似乎不太活跃。sxmo [-devel](https://lists.sr.ht/~mil/sxmo-devel)邮件列表确实会定期为项目的各个存储库获取补丁。

[由于 Sxmo 专注于提供极简环境，因此该项目不打算像postmarketOS](https://lwn.net/Articles/964574/) 那样切换到 systemd 也就不足为奇了 。在有关切换的常见问题解答中，postmarketOS 开发人员明确表示，[Sxmo 将坚持使用 OpenRC](https://postmarketos.org/blog/2024/03/05/adding-systemd/#what-about-openrc-s6-runit-dinit)作为其 init 系统。

#### 结论

对于大多数用户来说，Sxmo 甚至比 postmarketOS 更不适合。但是，对于精通技术、经验丰富的 Linux 用户来说，如果他们希望在手机上拥有轻量级且完全可编写脚本的界面，Sxmo 提供了一条与传统移动用户界面不同的路径。需要花一些时间来适应硬件按钮来控制手机的菜单式界面，但一段时间后，它的效果非常好。

[评论 (3 条)](https://lwn.net/Articles/981320/#Comments)

### [在 vDSO 中再次尝试 getrandom()](https://lwn.net/Articles/980447/)

作者：**Jonathan Corbet**\
2024 年 7 月 4 日

看来，随机数永远不可能足够随机，而且生成速度也不够快。经过多年的讨论，内核的[getrandom()](https://man7.org/linux/man-pages/man2/getrandom.2.html) 系统调用可能被大多数用户视为足够安全，但它仍然是一个系统调用。Linux 系统调用相对较快，但它们必然比直接调用函数慢。为了加快向用户空间提供安全随机数据的速度，Jason Donenfeld 整理了[getrandom()](https://lwn.net/ml/all/20240703183115.1075219-1-Jason@zx2c4.com)[的实现](https://lwn.net/ml/all/20240703183115.1075219-1-Jason@zx2c4.com)，它位于[虚拟动态共享对象 (vDSO) 区域](https://man7.org/linux/man-pages/man7/vdso.7.html)。

随机数据在很多应用程序中都有使用，包括自然现象建模、[UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)等标识符的生成以及游戏玩法；这就是[NetHack如何在黑暗房间的一角召唤出这三个炎魔。与安全相关的操作（例如随机数和密钥的生成）也大量使用随机数据 — 并且严重依赖于这些数据是否真的是随机的。有些应用程序需要大量的随机数据，以至于它们在](https://www.nethack.org/)getrandom()系统 调用中花费了大量时间。

解决此问题的一个可能方法是在用户空间中生成随机数，可能由来自内核的随机数据作为种子；多年来，许多开发人员都采用了这种方法。但是，正如 Donenfeld 在他的补丁系列的附信中所解释的那样，这种方法并不理想。内核对系统中的熵量以及生成真正随机数据所需的内容有最好的了解。它还知道虚拟机分叉等事件，这些事件可能会危及随机数生成器并需要重新播种。他总结道：

> 可以做出的最简单的陈述是，在某个时间点 T1 扩展 getrandom() 种子的用户空间 RNG 几乎总是比每次需要随机数时调用 getrandom() 更糟糕。

始终调用getrandom()可确保获得最佳随机数据，但相关的性能问题仍然存在。将该函数移入 vDSO 可以帮助解决该问题。

#### vDSO 中的getrandom()

vDSO 是一种特殊机制，用于加速需要内核参与的任务，但在用户空间中也可以很好地执行。它包含内核直接在用户空间中提供的代码和数据，这些代码和数据位于映射到每个线程地址空间的内存区域中。经典的 vDSO 函数是[gettimeofday()](https://man7.org/linux/man-pages/man2/gettimeofday.2.html)，它返回内核保存的当前系统时间。此函数可以作为系统调用来实现，但这会减慢频繁查询时间的应用程序的速度，而这种应用程序有很多。因此，Linux vDSO 包含gettimeofday()的实现；该实现可以简单地读取与内核共享的内存中的时间变量并将其返回给调用者，从而无需进行系统调用。

getrandom()是一种类似的函数；它从内核读取数据并将其返回到用户空间。因此， getrandom()的 vDSO 实现可能有意义。但是，这种实现必须谨慎进行；它应该返回与直接调用内核一样随机的数据，并且它必须能够抵御可能损害线程随机数生成状态的事件类型（例如 fork）。

在 Donenfeld 的实现中，用户空间程序将继续像往常一样调用getrandom()，无需进行任何更改。不过，在底层，C 库需要进行一些重大更改，该库为系统调用 提供了getrandom()包装器。

#### 州-区分配

随机数生成器对存储在内存中的某些状态数据进行处理。当需要随机数据时，伪随机数生成器会根据该状态创建数据，从而改变进程中的状态。每个线程都必须有自己的状态，并且必须小心避免在进程分叉、核心转储、虚拟机分叉或检查点等事件期间暴露该状态。应定期用随机数据重新填充该状态，特别是在其内容可能受到损害时。

getrandom() 的 vDSO 实现要求内核分配用于此状态的内存。因此，C 库必须做的第一件事就是为它认为可能运行的尽可能多的线程分配此状态存储。这可以通过新的系统调用完成：

```
结构vgetrandom_alloc_args {
    u64 标志；
  	u64数字；
  	u64 每个大小；
  	u64 字节_分配；
};
无效* vgetrandom_alloc（结构vgetrandom_alloc_args * args，size_t args_len）；
```

args 指向的结构描述了分配请求，而args_len是sizeof(\*args)；这允许在将来需要时以兼容的方式扩展结构。在该结构中，flags当前必须为零， num是请求内核分配的线程状态区域的数量。成功返回后，num将设置为实际分配的区域数量，size_per_each描述状态区域的大小，bytes_allocated是分配的内存总量。返回值将指向分配区域的基数。

分配的区域是普通的匿名内存，只不过它将在内核中使用多个虚拟内存区域标志进行特殊标记。VM_WIPEONFORK标志会导致在进程分叉时将其内容清零（这样两个进程就不会生成相同的随机数流），VM_DONTDUMP会阻止其内容写入核心转储，而VM_NORESERVE则会导致它不被计入进程的锁定内存限制。Donenfeld 还添加了一个新标志用于此区域：VM_DROPPABLE允许内存管理子系统在需要时简单地回收内存；由于这是匿名内存，因此在回收后访问它将导致分配一个新的、零填充的页面。结果是内存应该保持私有，但内核可以随时将其清零（或回收，效果相同）。

#### 生成随机数据

内核还与包含以下结构的 vDSO 共享一些内存：

```
结构 vdso_rng_data {
u64 代；
u8 已准备好；
};
```

vDSO 版本的getrandom() 使用这个结构，它有以下原型：

```
ssize_t vgetrandom（void *buffer，size_t len，无符号整数标志，
                   无效* opaque_state，size_t opaque_len);
```

前三个参数与getrandom()类似，描述所需的随机数据量以及调用是否应阻塞以等待内核的随机数生成器准备就绪。最后两个参数则描述由vgetrandom_alloc()分配的状态区域之一。此函数的作用是提供与 getrandom()相同的行为。

它首先查看共享结构中的is_ready字段；如果内核的随机数生成器尚未准备好， vgetrandom()将直接调用getrandom()来处理请求。但是，一旦随机数生成器初始化完毕，就不再需要这种后备。因此，接下来要做的是将生成计数（跟踪内核的随机数生成器重新播种的次数）与存储在状态区域中的生成计数进行比较。如果两者不匹配，则必须使用从内核获得的随机数据重新播种状态区域。

首次分配状态区域时，它会被清零，因此在那里找到的生成编号将为零，这将永远不会与内核的生成编号匹配；这将导致状态区域在第一次调用vgetrandom()时被播种。如果内核清除了该区域，例如由于 fork（VM_WIPEONFORK）或内存被回收（VM_DROPPABLE），也会发生同样的事情。因此，内核能够随时清除该内存，因为知道vgetrandom()会做正确的事情。

一旦确定状态区域处于良好状态， vgetrandom()就会使用它来生成请求的随机数据，使用内核本身使用的相同算法。安全地进行此计算有点棘手；如果进程在进行过程中分叉或核心转储，则堆栈上保存的任何数据都可能暴露。因此 vgetrandom()必须使用完全不使用堆栈的[ChaCha20 流密码](https://datatracker.ietf.org/doc/html/rfc7539)实现。补丁系列仅包含此密码的 x86 实现；其他架构似乎肯定会效仿。

作为将生成的数据返回给调用者之前的最后一步， vgetrandom()会再次检查代数。例如，如果在执行调用时内核擦除了状态区域，则代数检查将失败。在这种情况下， vgetrandom()将放弃其工作并重新开始。

Donenfeld 将这项工作的最终结果描述为“非常出色 (uint32_t 生成速度提高了约 15 倍) ”，并高兴地指出“它似乎正在发挥作用”。

#### 前景

LWN 最后一次[审视这项工作](https://lwn.net/Articles/919008/)是在 2023 年初。当时，有很多反对意见，其中许多都集中在对内存管理子系统的VM_DROPPABLE更改上，其中包括一些棘手的、特定于 x86 的技巧。几个月后，当补丁系列的[第 15 版](https://lwn.net/ml/linux-kernel/20240521111958.2384173-1-Jason@zx2c4.com/) 发布时，VM_DROPPABLE 仍然存在，但逻辑已被大大简化，希望能够解决这些问题，似乎成功了。现在似乎没有人反对将这个系列纳入其中。

从当前版本 (20) 开始，这项工作已添加到 linux-next 进行更广泛的测试；如果一切顺利，它可能会在本月底的 6.11 合并窗口上线。当然，“如果一切顺利”，包括通过 Linus Torvalds 的审核，他这次没有发表评论；不过，他对以前的版本[并不满意](https://lwn.net/ml/linux-kernel/CAHk-=wg_6Uhkjy12Vq_hN6rQqGRP2nE15rkgiAo6Qay5aOeigg@mail.gmail.com/)。如果主线合并成功，将所需更改集成到 C 库中的工作就可以开始了。最终结果将是一个重大的内部变化，但用户唯一应该注意到的是他们的程序运行速度更快了。

[评论 (25 条)](https://lwn.net/Articles/980447/#Comments)

### [内核中有利于卸载的网络加密](https://lwn.net/Articles/980430/)

作者：**Daroc Alden**\
2024 年 7 月 9 日

[PSP 安全协议](https://github.com/google/psp) ( PSP) 是一种透明地加密数据包的方法，它有效地将加密和解密任务转移到 Google 用于数据中心内部连接的网络接口卡 (NIC)。该协议类似于 [IPsec](https://en.wikipedia.org/wiki/IPsec)，因为它允许将任意流量包装在加密层中。不同之处在于 PSP 封装在 UDP 中，并且从一开始就设计为减少 NIC 必须跟踪的状态量，以便发送和接收加密流量，从而允许更多同时连接。Jakub Kicinski [希望](https://lwn.net/ml/netdev/20240510030435.120935-1-kuba@kernel.org/)在 Linux 内核中添加对该协议的支持。

#### 协议

PSP 是一个相当简单的协议。它完全避开了如何进行安全密钥交换的话题，假设连接两端的应用程序能够以某种方式交换对称加密密钥。这并不是一个不合理的设计决定，因为 IPsec 做同样的事情。目前有几种用于安全交换密钥的协议，例如[Internet 密钥交换](https://en.wikipedia.org/wiki/Internet_Key_Exchange)或 [Kerberized Internet 密钥协商](https://en.wikipedia.org/wiki/Kerberized_Internet_Negotiation_of_Keys)。通常，这些协议与对称密钥的来源无关。PSP 略有不同。为了支持硬件卸载，PSP 要求 NIC 本身为 PSP 连接生成密钥。PSP 架构 [规范](https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf)详细介绍了 NIC 应如何执行此操作。

主要要求是 NIC 应该能够从相当有限的信息量中重新导出会话密钥 — 具体来说，从 32 位“安全参数索引”(SPI) 值和存储在设备上的密钥中重新导出会话密钥。该密钥由 NIC 生成，并根据需要使用安全密钥导出函数为每个连接导出会话特定的加密密钥。因此，仅 SPI 不足以解密数据包；这允许将 SPI 包含在 PSP 数据包中，让 NIC 动态重新导出数据包的加密密钥。反过来，这意味着 NIC 实际上不需要存储加密密钥即可接收和处理数据包，从而大大减少了设备上所需的内存量。

不幸的是，这种重新派生密钥的要求是有代价的——PSP 连接是单向的。对于需要双向通信的实际用例，应用程序需要为每个方向设置单独的 PSP 连接。由于重新派生密钥需要访问存储在 NIC 上的设备密钥，因此只有接收 NIC 才能重新派生它，因此传输设备仍然需要将密钥存储在某个地方。虽然这可能在 NIC 上，但 PSP 规范保留了硬件实现的可能性，即要求计算机将加密密钥与任何传输的数据包一起发送到 NIC。

为了加密数据包，PSP 使用 AES-128-GCM 或 AES-256-GCM。它们都是 [带关联数据的认证加密](https://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data)(AEAD) 方案 — 它们保证收到的数据未被篡改（认证），并将一些加密数据与一些关联的纯文本数据捆绑在一起。在 PSP 的情况下，这用于实现偏移，允许发送方将封装在 PSP 中的协议标头保持未加密状态，同时仍保护内容。仅支持两种 AES 模式可使 PSP 的实现复杂性保持在较低水平。

PSP 还具有数据包布局，旨在通过在标头中提供明确的长度并使用比 IPsec 更少的可选标头，使硬件解析数据包更加高效。结合独特的密钥派生方案，PSP 最终比其他加密协议（如 IPsec 或 TLS）更易于硬件实现。

虽然 Google 是 PSP 的发起者和目前最大的用户，但该协议可能对其他用户有用。与其他加密协议相比，PSP 需要的设备内存少得多，因此可以扩展到更多的连接。由于该协议不强制要求密钥交换标准，因此对于用户控制连接两端但仍希望确保流量可以加密的环境来说，PSP 可能是一个不错的选择。

#### 讨论

尽管 Google 认为该协议非常有用，但内核开发人员对于在内核中添加另一种加密协议仍心存疑虑，因为内核已经处理了 IPsec、WireGuard、TLS 和其他协议。Paul Wouters 对 Kicinski 想要将 PSP 添加到内核 [表示惊讶](https://lwn.net/ml/netdev/1da873f4-7d9b-1bb3-0c44-0c04923bf3ab@nohats.ca/)，因为 IETF 拒绝以该协议与 IPsec 太相似为由对其进行标准化。

Steffen Klassert [分享了](https://lwn.net/ml/netdev/ZlWm/rt2OGfOCiZR@gauss3.secunet.de/)IPsecME 工作组正在起草的 一份 [草案，该草案涵盖了一些与 PSP 相同的用例。不过，Willem de Bruijn](https://datatracker.ietf.org/doc/draft-klassert-ipsecme-wespv2/) [指出](https://lwn.net/ml/netdev/6655e0eecb33a_29176f29427@willemb.c.googlers.com.notmuch/)，这可能并没有听起来那么有用，因为已经有硬件设备实现了 PSP 。“努力实现一个能够获得相同好处的 IETF 标准协议是有意义的。但这与启用已经实现的功能无关。 ”

这个答案 [并没有让 Wouters 满意](https://lwn.net/ml/netdev/81646030-00b9-10ad-abed-a7a78f0c511e@nohats.ca/)，他问道：“ Linux 内核应该有多少种不同的数据包加密方法？ ”他说，等待协议标准化可以提供互操作性，并有机会确保协议实际上对多种用例有用。他指出，PSP 和 IPsec 还可以使用大量相同的 NIC 硬件。

“当然，我并不反对标准化流程的优点。只是目前 PSP 还没有定论”，de Bruijn [回答道](https://lwn.net/ml/netdev/66561e53a11be_2a1fb929472@willemb.c.googlers.com.notmuch/)。Klassert [同意](https://lwn.net/ml/netdev/ZllpgEvQ4QnfP3m7@gauss3.secunet.de/)需要支持现有的 PSP 用户，但他认为，努力标准化满足所有人需求的现代加密协议仍然很重要。他邀请 Google 派代表参加 IETF IPsecME 工作组会议，讨论该主题。De Bruijn [表示，该公司将](https://lwn.net/ml/netdev/6659e2d5cd07e_3fde492947a@willemb.c.googlers.com.notmuch/)。

但一些评论者也对 Kicinski 的补丁集提出了技术上的反对意见。他提出的 API 允许用户空间在套接字上设置 PSP 加密密钥，之后通过该套接字传输的数据将被加密。问题在于这与重传究竟如何交互。PSP 封装在 UDP 中，无法保证数据完整或按顺序到达，因此将细节留给更高级别的协议。但 Kicinski 主要对 PSP 作为 TLS 的替代品感兴趣——当然，它运行在 TCP 之上。PSP 支持包装 TCP，但只是通过加密单个数据包，而不是参与 TCP 的重传逻辑。

总之，这会产生一些极端情况，de Bruijn [指出](https://lwn.net/ml/netdev/66416bc7b2d10_1d6c6729475@willemb.c.googlers.com.notmuch/)。在 PSP 密钥与套接字关联后，内核应该如何处理纯文本数据的重新传输？“与 TLS 卸载一样，数据在排队时会标注‘用于加密’。因此，之前排队的数据或此类数据的重新传输永远不会被加密”，Kicinski [解释道](https://lwn.net/ml/netdev/20240529103505.601872ea@kernel.org/)。

De Bruijn 对此 [并不完全满意](https://lwn.net/ml/netdev/6657cc86ddf97_37107c29438@willemb.c.googlers.com.notmuch/)，他指出这仍然会留下一些极端情况。如果一个对等点升级连接，而另一个对等点决定断开连接，会发生什么情况？“如果（如果）这种情况可能发生，那么连接就无法干净地关闭。 ”作为回应，Kicinski [建议](https://lwn.net/ml/netdev/20240530125120.24dd7f98@kernel.org/)“只有在我们看到一些加密数据后才强制加密无数据段”。De Bruijn [同意](https://lwn.net/ml/netdev/6659d71adc259_3f8cab29433@willemb.c.googlers.com.notmuch/)这可能会有所帮助，但仍然担心内核 API 仍可能以破坏协议正确性的方式被使用，并建议可能需要一些更详尽的文档。

作为回应，Kicinski [整理了](https://lwn.net/ml/netdev/20240604170849.110d56c1@kernel.org/)一些序列图，展示了如何设置和拆除 PSP 安全套接字。De Bruijn [认为](https://lwn.net/ml/netdev/6660c673921ff_35916d294ef@willemb.c.googlers.com.notmuch/)这是一个重大改进，但仍不确定是否已处理了所有边缘情况。

Lance Richardson 也对内核 API [提出了](https://lwn.net/ml/netdev/CAHWOjVJ2pMWdQSRK_DJkx7Q9zAzLx6mjE-Xr3ZqGzZFUi5PrMw@mail.gmail.com/)一些问题，指出似乎没有真正支持重新密钥套接字，而 PSP 要求每 24 小时重新密钥一次。在 [后续消息](https://lwn.net/ml/netdev/CAHWOjVL2hM4Lv=jNAv9CmLHYJL5ZBHmDH=ySQr7fr1Z6kgAvjg@mail.gmail.com/)中，Richardson 建议，这可能很简单，只需在重新密钥后保留旧密钥一两分钟即可。Kicinski [同意这很有道理](https://lwn.net/ml/netdev/20240628164152.34b69c01@kernel.org/)，并承诺将其添加到补丁集的下一个版本中。

虽然使用 PSP 的理由很多，而且支持它的硬件的存在也是一个好兆头，但缺乏标准和实施方面的问题表明，支持最终实现可能还需要一段时间。不过，未来我们可能会看到另一种加密协议进入内核。具体细节仍有待观察。

[评论 (15 条)](https://lwn.net/Articles/980430/#Comments)

### [用于 tree-in-dcache 文件系统的新 API](https://lwn.net/Articles/980558/)

作者：**Jake Edge**\
2024 年 7 月 9 日

______________________________________________________________________

[最小二乘多模+带通滤波器](https://lwn.net/Articles/lsfmmbpf2024/)

有许多内核文件系统将其目录条目直接存储在目录条目缓存 (dcache) 中，而无需为这些对象设置任何永久存储。Al Viro 在 2024 年[Linux 存储、文件系统、内存管理和 BPF 峰会的](https://events.linuxfoundation.org/lsfmmbpf/)文件系统跟踪会议开始时表示，它最初是[ramfs](https://docs.kernel.org/filesystems/ramfs-rootfs-initramfs.html)的一个“巧妙的破解” 。不幸的是，随着这种技术的使用扩展到其他文件系统，已经出现了许多失控的范围蔓延。他想讨论他正在研究的一些新基础设施，以尝试清理其中的一些问题。[](https://events.linuxfoundation.org/lsfmmbpf/)

[![[艾尔·维罗]](https://static.lwn.net/images/2024/lsfmb-viro-sm.png "艾尔维罗")](https://lwn.net/Articles/981165/)

Viro 展示了一些关于他的想法的[笔记](https://ftp.linux.org.uk/pub/people/viro/notes)，以配合他的演讲；本文的部分内容来自这些笔记。他有一个补丁集来实现这些想法（包含在他的[“untested.persistency”分支](https://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs.git/log/?h=untested.persistency)中），他说，这是一个“正在进行中的工作”，尚未经过测试，可能无法在 x86 以外的任何平台上编译。他想描述它要解决的问题以及它是如何解决的。

这一切都始于 Linus Torvalds 演示如何创建没有后备存储的文件系统。该技术将所有文件和目录保存在缓存中，是 ramfs 的基础。使用了“受控 dentry \[目录条目\] 泄漏”；人为增加引用计数以确保目录条目不会被逐出。卸载完成后，它们都会被清除。

tmpfs、hugetlbfs 和其他地方都采用了该技术，因为它比 procfs 使用的更简单。但是，其他一些用户会出现一些问题，而这些问题在最初版本中并不存在。最初的意图只是针对从用户空间填充的文件系统，但最终它被用于由内核填充的文件系统，或者更糟的是，同时由内核和用户空间填充的文件系统。

例如，[rmdir()](https://man7.org/linux/man-pages/man2/rmdir.2.html) 仅删除空目录，但 configfs 用户空间工具期望系统调用能够删除已填充子树（如果其所有条目均由内核创建）。如果有用户创建的子目录，则工具期望 rmdir ()失败。Christian Brauner 指出，控制组文件系统 (cgroupfs) 也有此行为。Viro 表示，这种文件系统必须实现自己的rmdir()，因为它非常专业。对于 configfs，它需要检查目标内是否有用户创建的目录（或任何正在进行的目录）。他说，代码“很糟糕”。

Viro 表示，确实需要一些基础设施来帮助这些文件系统。目前有大约十几种不同的子目录删除处理实现，但没有一种做得正确。他的想法是引入一个标志DCACHE_PERSISTENT ，用于标记“可控泄漏”的目录项，以便正确处理它们。然后内核发起的操作和来自用户空间的操作可以设置该标志，以便以相同的方式处理它们，而目前情况并非如此。

[将会有两个新函数，它们将与dget()](https://elixir.bootlin.com/linux/v6.9.8/source/include/linux/dcache.h#L312) 和[dput()](https://elixir.bootlin.com/linux/v6.9.8/source/fs/dcache.c#L824) 相对应 （它们获取和释放对目录条目的引用）；d_make_persistent()将执行与dget() 相同的操作并设置标志，而 d_make_discardable()将执行dput()并清除它。有新的辅助函数来处理简单的文件系统（如 ramfs）和更复杂的文件系统，包括处理一些开放编码的目录删除代码的变体。注释文件中有更多详细信息。

Viro 表示，仍有四个文件系统需要转换。它们都有需要解决的“有趣问题”；其中两个是针对[USB 小工具的](https://www.kernel.org/doc/html/v4.17/driver-api/usb/gadget.html)，一个是 configfs，另一个是 apparmorfs。他的补丁集的 diffstat 显示，这些更改实际上会导致从树中净删除大约 500 行代码。

他原本希望与 Christoph Hellwig 讨论 configfs，但 Christoph Hellwig 当天晚些时候才到场，因此未能出席。他计划与 Greg Kroah-Hartman 讨论 USB 小工具文件系统，但不确定与谁讨论 apparmorfs。他说，apparmorfs 中存在一些奇怪的锁定，他曾向 AppArmor 开发人员提到过，但无果而终。随着会议时间的流逝，大家就此问题和相关工作进行了进一步讨论。

[评论 (2 条)](https://lwn.net/Articles/980558/#Comments)

### [改进伪文件系统](https://lwn.net/Articles/981155/)

作者：**Jake Edge**\
2024 年 7 月 10 日

______________________________________________________________________

[最小二乘多模+带通滤波器](https://lwn.net/Articles/lsfmmbpf2024/)

eventfs 文件系统提供了一个可供各种 Linux 跟踪工具（例如 ftrace、perf、uprobes 等）使用的跟踪点接口；它旨在成为 tracefs 文件系统的一个版本，可根据需要动态分配其条目。正如 Steven Rostedt 在2022 年 [Linux 存储、文件系统、内存管理和 BPF 峰会上的一次](https://events.linuxfoundation.org/lsfmmbpf/)[会议](https://lwn.net/Articles/895111/)上所描述的那样，目标是减少多个 tracefs 实例所需的内存。他回到了 2024 年的峰会，进一步讨论了如何使伪（或虚拟）文件系统（例如 tracefs/eventfs）更像常规的 Linux 文件系统，其中目录条目（dentries）和 inode 仅在需要时创建（和缓存）。[](https://events.linuxfoundation.org/lsfmmbpf/)

#### 背景

他首先介绍了 eventfs 的一些背景知识；它基于 tracefs，而 tracefs 又基于[debugfs](https://docs.kernel.org/filesystems/debugfs.html)。由于 debugfs 提供的接口，eventfs 为其每个文件和目录维护了 dentry。在 Rostedt提议今年[举办虚拟文件系统会议的同时，eventfs](https://lwn.net/ml/linux-mm/20240125104822.04a5ad44@gandalf.local.home/)[正在进行大规模的重新设计](https://lwn.net/Articles/960088/)，以避免出现一些问题，其中一些问题与安全有关。作为其中的一部分，Linus Torvalds 以他独特的方式明确表示，以 dentry 为中心的方法是不对的。

[![[史蒂文·罗斯泰特]](https://static.lwn.net/images/2024/lsfmb-rostedt-sm.png "史蒂文·罗斯泰特")](https://lwn.net/Articles/981390/)

在 2022 年的会议上，Christian Brauner 建议使用[kernfs](<https://en.wikipedia.org/wiki/Kernfs_(Linux)>)作为 eventfs 的基础。当 Rostedt 查看时，他发现只有 sysfs 和控制组使用 kernfs，而且这似乎并不适用于他想要做的事情。在最近尝试了几次之后，他发现将所有 debugfs 和 tracefs 转换为使用 kernfs 可能是有意义的，但对于 eventfs 来说这行不通，他说。

他正在研究的一件事是跟踪 Chromebook 的基础设施，其中一些只有 2GB 的 RAM；“内存在那里非常抢手”。eventfs 中有“成千上万个文件”；eventfs 的新实例会创建一个新的环形缓冲区，但它们也会复制大多数文件，这会占用大量内存。因此，eventfs 变成了一个动态文件系统，它不会在实际需要时才创建 dentry 和 inode，从而节省了大量内存。

与 Torvalds 分歧的关键在于 Rostedt 不了解文件系统应该如何实现，以及 debugfs 的 API。Torvalds 询问 Rostedt 为什么在挂载文件系统之前就为 eventfs 创建 dentry。但是，使用[debugfs_create_file()](https://elixir.bootlin.com/linux/v6.9.8/source/fs/debugfs/inode.c#L457)创建文件 会返回 dentry，因此 Rostedt 认为应该这样做。Al Viro 指出，eventfs 远远超出了 debugfs 曾经做过的事情，这“真的很可怕”；他“不喜欢”debugfs 所做的事情，但 eventfs 做得更进一步。Viro 说，在对 eventfs 进行修复后，事情“更加理智”。

Rostedt 表示，现在他了解了更多信息，他担心 debugfs 需要注意；“也许我们应该更新它”。Viro 指出，debugfs 存在一些对象生命周期问题，并且在对正在删除的文件进行 I/O 时缺乏“合理的排除”。Rostedt 想知道是否应该将 debugfs 切换到使用 kernfs，但 Viro 表示“kernfs 有不同的问题”。

Viro 表示，Kernfs 并不完全支持命名空间。Brauner 认为 debugfs 不需要命名空间支持，但 Rostedt 和 Viro 表示人们希望能够在容器内安装 debugfs。“这从表面上看是疯狂的”，Brauner 表示，“我们不会这么做”。

Rostedt 说，他遇到的一个问题是，开发人员开始使用 debugfs 进行一些项目，但一旦它获得一些关注，他们就想将其移至自己的文件系统。就目前而言，Debugfs 并不是一个真正好的基础。这就是发生在他身上的事情；“我在这里要说的是，不要让别人效仿我的脚步”。因此，他认为应该将 debugfs 切换到更好的接口，以便人们可以将其用作文件系统的基础。

#### 路径？

在 Brauner 和 Viro 就 debugfs 的现状进行了一些讨论之后，Rostedt 稍微改变了话题，询问内核开发人员如果想将他们的文件系统从 debugfs 移到真正的文件系统，正确的路径是什么。Viro 重申了他对 debugfs 的一些担忧，包括在 debugfs 文件被删除后应用程序是否能够继续从打开的文件描述符读取。

Rostedt 想知道 debugfs 接口中 dentry 的使用情况；他认为对于那些安装它的人来说，可能会有内存问题。Brauner 说，对于 debugfs 中有多少文件，没有真正的控制，因为任何随机驱动程序都可以随时添加条目。写入其中一个文件可能会导致系统死锁或崩溃。出于这些和其他原因，“在生产系统上安装 debugfs 是……冒险的”。

Dave Chinner 说 Rostedt 提出了错误的问题。从 debugfs 开始，然后试图将该代码移至生产文件系统是错误的。如果它注定要用于生产，则应该在 sysfs 中开发，但 Rostedt 指出 sysfs 具有限制性；sysfs 文件应该只有一个值。Chinner 说，这一限制经常被忽略。

Rostedt 表示，不专注于文件系统的开发人员选择 debugfs 作为起点，因为这样做很容易；他们通常只是为了调试目的才这样做。后来发现该功能很有用，但现在代码是围绕 debugfs 构建的，这“不是正确的做法”，他说。

Chinner 建议“向专家请教”，但 Rostedt 表示“很多时候专家们都在忙着做自己的事情”。他表示，自己在创作过程中发布了自己作品的不同版本，但很少得到专家们的任何评论。

Brauner 和 Viro 讨论了一些可能合理扩展以适应 eventfs 用例的方法，但并没有真正得出结论。Ted Ts'o 说，问题的一部分在于“没有一个通用的解决方案”可以指导内核开发人员；debugfs 对于少量文件和只需要一个实例的情况完全没问题。对于有多个实例和数百万个文件的情况，没有现成的代码可以参考。因此，不可能给出与可能需要的所有文件系统相关的建议。

但 Rostedt 表示，他并不是想解决 eventfs 问题（这是一个特殊的用例），而是想弄清楚应该告诉那些想要将一个相当简单的基于 debugfs 的文件系统迁移到真实文件系统的开发人员什么。Brauner 说，首先需要回答一些问题：文件系统是否有一个实例，还是每次挂载都会创建一个新实例？文件系统是否需要具有命名空间感知能力？如果没有这些答案，就很难说出正确的路径是什么。

随着时间的流逝，Rostedt 说，会议上讨论的内容“对我来说就像金子一样”。他认为讨论的内容需要完整记录下来，而需要回答的问题显然是其中很大一部分。Viro 说这听起来像一份“常见问题”文件，这引起了一些笑声。不过，Rostedt 表示同意，并询问是否有任何此类文档。Brauner 说没有，“我认为这是公平的观点”；例如，如今大多数文件系统都需要具有命名空间感知能力，但并没有真正好的例子可以指导开发人员。然而，这是否会导致文档补丁尚不清楚。

[评论 (未发表)](https://lwn.net/Articles/981155/#Comments)

### [使用 nmbl 启动引导加载程序](https://lwn.net/Articles/979789/)

作者：**Joe Brockmeier**\
2024 年 7 月 8 日

______________________________________________________________________

[DevConf.cz](https://lwn.net/Archives/ConferenceByYear/#2024-DevConf.cz)

在[DevConf.cz 2024](https://www.devconf.info/cz/)上，Marta Lewandowska 发表了一个演讲，讨论了一种启动 Linux 系统的新方法，即“[不再使用引导加载程序：请使用内核](https://pretalx.com/devconf-cz-2024/talk/W3AVCT/)”。该演讲[可在 YouTube 上观看](https://www.youtube.com/watch?v=ywrSDLp926M)，介绍了一个名为 nmbl（代表“不再使用引导加载程序”，发音为“nimble”）的新项目。其想法是使用 [统一内核映像](https://uapi-group.org/specifications/specs/unified_kernel_image/)(UKI)摆脱引导加载程序（例如 [GNU GRUB](https://www.gnu.org/software/grub/)），从而完全消除对单独引导加载程序的需求。nmbl 还处于早期阶段，目前该项目仅在虚拟机上进行测试，但这个想法很有吸引力。如果成功，与 GRUB 和其他单独的引导加载程序相比，nmbl 可以提供安全性、性能和维护优势。[](https://uapi-group.org/specifications/specs/unified_kernel_image/)

#### 基本原理

多年来，长期使用 Linux 的用户已经见识过引导加载程序（一种初始化硬件并加载操作系统的软件）。在早期，用户可能使用[loadlin](https://en.wikipedia.org/wiki/Loadlin)从 MS-DOS 引导到 Linux。然后是[Linux Loader](https://wiki.debian.org/LILO) (LILO)。它一直是 Linux 发行版的流行选择，直到 2000 年代中期，Linux 发行版开始转向[GRand Unified Bootloader](https://wiki.debian.org/Grub) (GRUB)，然后是[GRUB 2](https://wiki.debian.org/GRUB2)（它取代了 GRUB 遗留版本，因此我们在此之后将只说“GRUB”）。[SYSLINUX系列引导加载程序是从软盘、CD-ROM（](https://wiki.syslinux.org/wiki/index.php?title=SYSLINUX) [ISOLINUX](https://wiki.syslinux.org/wiki/index.php?title=ISOLINUX)）、使用 PXE 引导的网络服务器（[PXELINUX](https://wiki.syslinux.org/wiki/index.php?title=PXELINUX)）和各种文件系统（[EXTLINUX](https://wiki.syslinux.org/wiki/index.php?title=EXTLINUX) ） 引导的流行选择。这不是一个详尽的列表，只是 x86/x86_64 系统上更广泛使用的引导加载程序的一个示例。当然，其他平台需要自己的引导加载程序。

Lewandowska 是 Red Hat 的一名质量工程师，她在演讲的开头讨论了引导加载程序的用途以及可能出错的地方。她说，引导加载程序是第一个运行的软件，“它为启动和操作系统运行做好一切准备”，然后将控制权移交给内核。

她说，在启动台式机或笔记本电脑系统时，这听起来可能不是什么大问题，但对于多种架构、复杂的存储方案和通过网络启动来说，情况就变得复杂得多。所有这些都必须是可能的，而且“所有向我们提交错误的人都知道”它可能以多种方式出错。

除此之外，还有安全启动。安全启动的理念当然是确保机器“从一开始就没有任何恶意软件”，她说。信任链始于硬件，硬件只会加载受信任的引导程序，而引导程序只会加载受信任的内核。Lewandowska 简要解释了这在 UEFI 和 Linux 系统中是如何工作的。当系统启动时，如果固件具有受信任的签名，它将加载第一阶段的引导程序（称为 shim）[。](https://github.com/rhboot/shim)然后它将加载已签名的引导程序，在本例中为 GRUB。接下来，GRUB 将提供引导选项菜单和/或允许用户编辑引导选项。然后 GRUB 将使用 shim 安装的协议验证所选内核的签名。GRUB 还必须加载 initramfs [，](https://wiki.debian.org/initramfs)即用于引导内核的初始根文件系统映像，Lewandowska 称这是“最大的安全漏洞”，因为它没有签名。

她说，GRUB 很棒，但它也很复杂，需要处理 Linux 内核中重复的大量功能。当然，它也有安全漏洞。她展示了一张幻灯片，其中列出了自 2021 年以来 GRUB 的 15 个 CVE。（幻灯片[在这里](https://pretalx.com/media/devconf-cz-2024/submissions/W3AVCT/resources/nmbl_devconf_official_2024_YWjkEyN.odp)。）到目前为止，2024 年只有一个，但“相信我，还会有更多”，Lewandowska 说。除了 CVE 之外，GRUB 中还有许多常见的错误，例如文件系统、存储和内存分配错误，这些错误很难解决，而使用 GRUB 的人没有资源来修复。GRUB 的开发不像 Linux 内核那样积极，因此修复速度较慢。她指出，Red Hat 为 GRUB 提供了“数百个下游补丁”。“我们正在努力修复所有这些问题，但这是一项艰巨的任务，而且进展缓慢。”她说，这最终将我们带到了 nmbl。

#### 为什么选择 nmbl

Lewandowska 表示，nmbl 的理念是“将 Linux 中已经存在的一大堆东西拿来”，添加一些代码，然后将它们组合在一起。Nmbl 以 UKI 的形式提供：一个可移植执行/通用对象文件格式 (PE/COFF) 的单一映像，捆绑了启动所需的内核映像和资源。Nmbl 包括内核命令行、initramfs、内核和 UEFI 存根（使用[systemd-stub](https://www.freedesktop.org/software/systemd/man/latest/systemd-stub.html)），包装为可从 UEFI 固件运行的 UEFI 可执行文件。作为额外奖励，nmbl 可以签名，因此“现在整个东西都变得安全了”，包括 initramfs。

她说，其中大部分功能已经在 Fedora 中实现。Fedora 有用于生成 initramfs 映像的[Dracut](https://fedoraproject.org/wiki/Dracut)，并且一直在增加对 UKI 的支持。（LWN 报道过[Fedora 对 UKI 的计划，以及](https://lwn.net/Articles/918909/)[Fedora 40 中 UKI 支持的](https://lwn.net/Articles/969145/)进展。）Nmbl 还使用[grub-emu](https://manpages.ubuntu.com/manpages/trusty/man1/grub-emu.1.html) 来提供 Linux 用户已经熟悉的 GRUB 样式菜单。

在与演讲同时发布的一篇[博客文章](https://fizuxchyk.wordpress.com/2024/06/13/nmbl-we-dont-need-a-bootloader/)中，她解释了 nmbl 可能提供的优势。首先是缩短了启动时间。目前，nmbl 有两种变体正在开发中，一种可以直接启动所需的内核，另一种允许用户启动不同的内核。直接启动选项加载 nmbl 使用的相同内核，并执行切换[根](https://man7.org/linux/man-pages/man8/switch_root.8.html)以从 initrfamfs 切换到用户空间文件系统。另一个选项加载 nmbl UKI 并使用 grub-emu 显示可启动内核的菜单。然后它使用[kexec](https://man7.org/linux/man-pages/man8/kexec.8.html)启动最终内核并启动系统。当 nmbl 是目标内核时，它将大大减少启动时间，因为无需启动第二个内核。

Lewandowska 表示，它还将加快功能交付速度。“由于内核和引导加载程序代码不再需要重复，因此功能只需实现一次即可在两个地方使用。 ”此外，她写道，实现一次功能将减少重复工作，并担心内核文件系统驱动程序等会发生变化。由于引导加载程序和内核将是“同一个”，因此任何内核更改也将立即提供给引导加载程序。

她还大力宣传提高安全性的想法。她写道，将所有 initramfs 纳入签名二进制文件将“大大提高安全性”。除此之外，nmbl 将大大减少攻击面，“因为构成 nmbl 的新代码只有几百行，而 GRUB 有数十万行”。最后，Lewandowska 表示，由于 Linux 内核的社区规模更大，nmbl 将比 GRUB 本身受到更多的审查。

#### 初期

Lewandowska 表示，还有很多工作要做。nmbl 开发人员接下来想要做的是将 nmbl 与每个 Fedora 内核一起构建。即将推出的另一个功能是 shim A/B 启动，如果最新的 nmbl 内核因某种原因失败，它将允许回退到之前的 nmbl 内核。这将使失败的升级更容易恢复。nmbl的[概念验证](https://github.com/rhboot/nmbl-poc) (POC) 目前在 UEFI 上运行。从长远来看，该团队希望让 nmbl 在其他不使用 UEFI 的架构上运行。

对裸机的支持也在愿望清单上。在演讲的问答环节中，Lewandowska 表示，nmbl 的开发和测试目前主要在虚拟机上进行。她说，它已经在硬件上进行了测试，但最近没有。她发布了如何在 Fedora 39 的虚拟机中执行此操作的[说明](https://fizuxchyk.wordpress.com/2024/06/13/how-build-and-boot-nmbl-on-a-fedora-virtual-machine/) ，包括如何生成签名证书和注册密钥以使用 nmbl UKI 进行安全启动的指导。

nmbl 可能还需要几年时间才能取代 GRUB 成为大多数 Linux 用户的首选引导加载程序，但这是一个有趣的方法，如果成功的话，可能会有很多优势。

[评论 (已发布 54 条)](https://lwn.net/Articles/979789/#Comments)

**页面编辑**：Jonathan Corbet

## 本周 LWN.net 周刊

- [简介](https://lwn.net/Articles/980656/)：OpenSSH 漏洞；Fedora Atomic 启动问题；文本渲染；Firefox 128.0；GDB 15.1；报价；......
- [公告](https://lwn.net/Articles/980657/)：新闻通讯、会议、安全更新、补丁等。

**下一页**： [简要项目>>](https://lwn.net/Articles/980656/)

版权所有 © 2024，Eklektix，Inc.\
评论和公开帖子的版权归其创建者所有。Linux\
是 Linus Torvalds 的注册商标

[![LWN.net Logo](https://static.lwn.net/images/logo/barepenguin-70.png)LWN\
.netNews from the source](https://lwn.net/)[](https://lwn.net/)

- [**Content**](https://lwn.net/Articles/980654/#t)

  - [Weekly Edition](https://lwn.net/current/)
  - [Archives](https://lwn.net/Archives/)
  - [Search](https://lwn.net/Search/)
  - [Kernel](https://lwn.net/Kernel/)
  - [Security](https://lwn.net/Security/)
  - [Events calendar](https://lwn.net/Calendar/)
  - [Unread comments](https://lwn.net/Comments/unread)

  ______________________________________________________________________

  - [LWN FAQ](https://lwn.net/op/FAQ.lwn)
  - [Write for us](https://lwn.net/op/AuthorGuide.lwn)

- [**Edition**](https://lwn.net/Articles/980654/#t)

  - [⇒Front page](https://lwn.net/Articles/980654/)
  - [Brief items](https://lwn.net/Articles/980656/)
  - [Announcements](https://lwn.net/Articles/980657/)
  - [One big page](https://lwn.net/Articles/980654/bigpage)
  - [Previous week](https://lwn.net/Articles/979852/)
  - [Following week](https://lwn.net/Articles/981628/)

**User:**  **Password:**

|

|

# LWN.net Weekly Edition for July 11, 2024

### [Welcome to the LWN.net Weekly Edition for July 11, 2024](https://lwn.net/Articles/981575/)

This edition contains the following feature content:

- [New features in C++26](https://lwn.net/Articles/979870/): a look at some of the features that may appear in the next major version of the C++ standard.

- [Sxmo: a text-centric mobile user interface](https://lwn.net/Articles/981320/): a different approach to interactive mobile applications.

- [Another try for getrandom() in the vDSO](https://lwn.net/Articles/980447/): the ongoing effort to provide fast and secure random data to user space.

- [Offload-friendly network encryption in the kernel](https://lwn.net/Articles/980430/): a look at the PSP security protocol.

- Two more reports from LSFMM+BPF 2024:

  - [A new API for tree-in-dcache filesystems](https://lwn.net/Articles/980558/): filesystems that store their entire tree in the directory-entry cache have proliferated, without handling the edge cases well; a new API would try to clean up some of those problems.
  - [Improving pseudo filesystems](https://lwn.net/Articles/981155/): problems abound in pseudo (or virtual) filesystems, in part because there is a lack of guidance available for kernel developers who want to create one; what can be done to improve that?

- [Giving bootloaders the boot with nmbl](https://lwn.net/Articles/979789/): booting directly into the kernel and cutting out the bootloader middleman.

This week's edition also includes these inner pages:

- [Brief items](https://lwn.net/Articles/980656/): Brief news items from throughout the community.
- [Announcements](https://lwn.net/Articles/980657/): Newsletters, conferences, security updates, patches, and more.

Please enjoy this week's edition, and, as always, thank you for supporting LWN.net.

[Comments (none posted)](https://lwn.net/Articles/981575/#Comments)

### [New features in C++26](https://lwn.net/Articles/979870/)

By **Daroc Alden**\
July 5, 2024

ISO releases new C++ language standards on a three-year cadence; now that it's been more than a year since the finalization of C++23, we have a good idea of what [features could be adopted for C++26](https://en.cppreference.com/w/cpp/26) — although proposals can still be submitted until January 2025. Of particular interest is the addition of support for [hazard pointers](https://en.wikipedia.org/wiki/Hazard_pointer) and [user-space read-copy-update](https://lwn.net/Articles/573424/) (RCU). Even though C++26 is not yet a standard, many of the proposed features are already available to experiment with in GCC or Clang.

#### New threading libraries

Hazard pointers are a technique for building lock-free concurrent code. In a system with hazard pointers, each thread keeps a list of shared objects that it is currently accessing. Other threads can use that information to avoid modifying or freeing objects that are still in use.

In the [proposed C++ library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2530r3.pdf), a thread that wants to free a potentially shared object instead "retires" it, passing the responsibility for reclaiming the object to the library. Retiring an object is done atomically, such that there can be no new readers after an object is retired. When an object is retired, the library checks to see whether any existing hazard pointers reference it. If it is still referenced, it is added to a set of retired objects, which are rechecked periodically (when another object is retired, not on a timer). The object is freed once no hazard pointers reference it.

The [proposed interface](https://en.cppreference.com/w/cpp/header/hazard_pointer) requires any classes protected by a hazard pointer to be a subclass of hazard_pointer_obj_base. Then, users can call make_hazard_pointer() to create a hazard pointer. Calling the protect() method of the returned hazard pointer protects the object with the pointer, and the thread can use the object normally. A thread that wants to retire an object calls object->retire(), which hands it over to the library. In all, the proposed API would be used like this:

```
// Register a new (empty) hazard pointer with the library
hazard_pointer hp = make_hazard_pointer();

// Acquire a pointer to the object that needs protecting
const atomic<T*>& object = ...;

// Protect the pointer by putting it in the hazard_pointer
T* normal_pointer = hp.protect(object);

... // Perform operations using normal_pointer

// Remove the object from the hazard_pointer once done,
// or let RAII clean up the hazard_pointer.
hp.reset_protection(normal_pointer);

// Meanwhile, another thread could call
object->retire()
```

Hazard pointers aren't the only addition, however. User-space RCU support has also been [proposed for inclusion](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2545r1.pdf). RCU is a technique that is [widely used](https://lwn.net/Articles/262464/) in the Linux kernel. Access to an object protected by RCU is done through a pointer; when a thread wants to change the object, it first makes a separate copy, and then edits that copy. Finally, the thread atomically swaps the pointer to point to the new copy. Using a compare-and-exchange instruction lets the thread know that it will need to try again if it happened to contend with another writer. The library also keeps track of some information to determine when all readers have finished with the old version of the object, allowing the writing thread to free it. The exact details can vary between implementations, so the proposed API doesn't mandate a particular approach to ensuring that readers are done.

Like the hazard-pointer proposal, the new RCU library defines a rcu_obj_base class that objects which will be protected by RCU can inherit from. Unlike with hazard pointers, this inheritance is not required; [rcu_retire](https://en.cppreference.com/w/cpp/header/rcu) can be used on objects that are not descendants of that class.

Both libraries already have reference implementations available. There are several user-space RCU libraries cited, but both proposals list the Apache-2.0-licensed [folly](https://github.com/facebook/folly) library as the primary reference implementation. If accepted, these features will become part of the C++ standard library.

#### Other library changes

There's also a good number of proposals for features to include in the standard library that are smaller or less significant. C++26 could see a [debugging](https://en.cppreference.com/w/cpp/header/debugging) header that supplies a breakpoint() function, a [linear algebra](https://en.cppreference.com/w/cpp/header/linalg) header that incorporates features from [BLAS](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms), and a [text encoding](https://en.cppreference.com/w/cpp/header/text_encoding) header that lets users access the [IANA Character Sets registry](https://www.iana.org/assignments/character-sets/character-sets.xhtml) — the official list of character sets that can be used on the internet.

There's a long list of fixes and updates to other parts of the standard library, including [changes](https://wg21.link/P2497R0) to charconv functions, several updates to formatting and printing, [stable sorting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf) at compile time, changes to make more types usable as map keys, and several removals of deprecated items.

#### New core language changes

Also planned for the new standard are changes to the language itself. Some are relatively small changes; C++26 will probably contain [a clarification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2552r2.pdf) of what it means for an attribute to be ignorable, and [a change](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3106r1.html) to the wording describing how to determine the length of an array when some of the initializers use the [brace elision feature](https://en.cppreference.com/w/cpp/language/aggregate_initialization). There are also a handful of small fixes for string literals, such as [defining](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2621r2.pdf) previously undefined behavior during lexing (including specifying that unterminated string literals are ill-formed), [specifying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1854r4.pdf) that characters that can't be encoded in the source file's encoding are not permitted in string literals, and [clarifying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2361r6.pdf) when string literals should be evaluated by the compiler.

But most of the upcoming changes are a good deal more interesting. One [proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2809r3.html) would turn some infinite loops into defined behavior. This is particularly important for the correctness of some low-level code that uses infinite loops intentionally as a way to halt a thread. Infinite loops had originally been made undefined behavior in order to allow optimizing compilers to assume that programs made forward progress; in general, determining whether a loop condition ever becomes false is equivalent to the halting problem. If the compiler is allowed to assume that a loop will eventually halt, it can use that information to make optimizations that are otherwise not possible.

C and C++ have slightly different requirements for how implementations must treat infinite loops, however. C has an explicit exception for loops with constant control expressions. So, since C11, these two loops have been meaningfully different:

```
int cond = ...;

while (cond) {
    // ...
}

while (true) {
    if (!cond)
        break;
    // ...
}
```

The former loop can be assumed to eventually terminate, but the latter loop cannot. In contrast, C++11 allows the compiler to assume that both loops must eventually terminate. The proposal would change these rules so that "trivial" infinite loops — those with empty bodies — are not considered undefined behavior. This is different from what C specifies, but it would allow low-level code that actually intends to have a CPU spin in an empty loop.

Another change would [allow casting from void\* to other types in constexpr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf), which is C++'s mechanism for compile-time code execution. Over time, the language has slowly been expanding what is possible at compile time, mostly in the form of library changes to mark functions as constexpr. But there are still some fundamental restrictions around constexpr code, many of which deal with memory. Allowing constexpr code to use void pointers is another step toward loosening those restrictions.

That isn't the only compile-time improvement — there are proposals to [have static_assert() take a user-supplied message](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r3.pdf), as well as adding messages [to the = delete syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2573r2.html) (which allows the programmer to suppress the generation of methods that the compiler normally provides, such as copy constructors). Both of those changes could make it easier to communicate the reasoning behind compile-time checks and make writing maintainable code easier. There is also [a proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2748r5.html) to make binding a returned glvalue to a temporary value ill-formed. A glvalue is any expression where its evaluation determines the identity of an object or function — a "generalized lvalue" that could have something assigned to it. In other words, code like this will no longer be accepted:

```
const std::string_view& getString() {
    static std::string s;
    return s;
}
```

If getString() had returned a std::string directly, it would be — and remains — valid. The problem comes because a std::string_view& is a non-owning reference to a std::string_view. When the value is returned, the underlying std::string_view is freed, and the reference becomes dangling. Languages like Rust solve this problem with an ownership system; C++26 would not go that far — it would still be possible to write a function that returns a dangling reference. But it would become a bit more difficult to do by mistake, since references to temporary values (such as the implicit conversion to std::string_view&) would be detected by the compiler.

#### Template improvements

C++26 also has a few improvements planned for the template system. In C++, when a template takes a parameter with a "..." before the name, the compiler creates a special structure holding multiple parameters called a "pack". [A small proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2662r3.pdf) would allow the \[\] operator to index into a pack in a template. To distinguish this from a normal index operation, the proposal provides new syntax for accessing an element of a pack: name...\[\]. For example:

```
template <typename... T>
constexpr auto first_plus_last(T... values) -> T...[0] {
    return T...[0](values...[0] + values...[sizeof...(values)-1]);
}
```

Packs can also be used in more places, with [one change](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r3.html) permitting them in the friend declaration of a class. This change is potentially useful because it permits programmers to use templates to implement the [passkey idiom](https://arne-mertz.de/2016/10/passkey-idiom/), a technique for exposing given methods only to particular classes.

The last proposed changes to the language itself to date include two changes to variable bindings: [allowing attributes on structured bindings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0609r3.pdf) and [allowing _ in a binding to discard a value](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf). Finally, there is [an obscure change](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2308r1.html) to how compilers are required to initialize template parameters, and [a change to braced initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2752r2.html) that makes them more efficient.

C++ may not be the first language people consider when thinking about evolving languages, but it still sees several important improvements in each edition. If no problems crop up, these changes will likely be accepted during the C++26 standardization meetings next year. In the meantime, there is still an open window to reflect on these changes and contribute additional suggestions.

\[Thanks to Alison Chaiken for the suggestion to cover user-space RCU that led to this article.\]

[Comments (134 posted)](https://lwn.net/Articles/979870/#Comments)

### [Sxmo: a text-centric mobile user interface](https://lwn.net/Articles/981320/)

July 10, 2024

This article was contributed by Koen Vervloesem

[Sxmo](https://sxmo.org/), short for "Simple X Mobile", is described on its web site as "a minimalist environment for Linux mobile devices"; it offers a menu-driven interface that is controlled with the phone's hardware buttons. Sxmo enables the user to send SMS messages from a text editor and is entirely customizable with shell scripts. This peculiar mobile user interface significantly differs from the prevailing approach—but it works.

[![[Sxmo main menu]](https://static.lwn.net/images/2024/sxmo-menu-sm.png "Sxmo main menu")](https://lwn.net/Articles/981347/)

While mobile user interfaces such as [Phosh](https://phosh.mobi/), [KDE Plasma Mobile](https://plasma-mobile.org/), and [Lomiri](https://lomiri.com/) have some differences between them, they are all rooted in the same philosophy. They center on touch-based interactions and display apps through icons, an approach influenced by the conventional point-and-click paradigm of desktop user interfaces. However, on the desktop, a text-centric approach centering on keyboard input and terminal programs following the Unix philosophy has remained popular among advanced users. Sxmo aims to offer such an environment for mobile devices.

There are two flavors of Sxmo: Xorg or Wayland. The Xorg version is based on a couple of [forks](https://sr.ht/~mil/sxmo/sources) of tools from the [suckless](https://suckless.org/) project, which has "a focus on simplicity, clarity, and frugality". This includes the dynamic window manager [dwm](https://dwm.suckless.org/), the menu system [dmenu](https://tools.suckless.org/dmenu/), and the simple terminal emulator [st](https://st.suckless.org/). The Wayland version uses some tools inspired by their Xorg counterparts, including the tiling Wayland compositor [Sway](https://swaywm.org/), the menu system [bemenu](https://github.com/Cloudef/bemenu?tab=readme-ov-file#bemenu), and the terminal emulator [foot](https://codeberg.org/dnkl/foot). In practice, both versions work similarly, with some minor low-level differences in configuration.

Sxmo is best supported on the [postmarketOS](https://postmarketos.org/) Linux distribution for mobile devices (previously [covered here](https://lwn.net/Articles/979522/)). Pre-built images of postmarketOS with Sxmo for various devices can be found on the [download](https://postmarketos.org/download/) page of the distribution. Alternatively, a custom image can be built by running pmbootstrap init and choosing sxmo-de-sway (for the Wayland version) or sxmo-de-dwm (for the Xorg version) as the interface. I tested Sxmo's Wayland version by installing a custom-built postmarketOS image.

#### Menu-driven interface

Since interacting with Sxmo deviates significantly from other mobile interfaces, its [user guide](https://man.sr.ht/~anjan/sxmo-docs-stable/USERGUIDE.md) is required reading, especially to learn about the actions behind the phone's hardware buttons. Most phones have three buttons on the side: volume-up, volume-down, and power. For each of these buttons, Sxmo triggers an action based on whether you tap the button once, twice, or thrice; a long-press can be used instead of tapping three times. This way, the user can start nine different actions solely by using the hardware buttons, just with the thumb. Touch-based input also works.

Sxmo's home screen is merely a background image featuring the current date and time, with a status bar on top that includes a workspace number (only one at first), and, next to it, status icons for the mobile network, WiFi connection, battery, volume, lock state, and time. The global system menu opens when the user taps on the volume-up button or swipes down from the top of the screen. While within a menu, the hardware buttons exhibit a different behavior: the volume-up button navigates to the previous item, while the volume-down button advances to the next item. The power button selects the current item. Tapping an item on the touch screen also selects it.

The global system menu gives access to various scripts and applications. Several menu items open an application in a terminal window upon selection. For instance, scanning for WiFi networks starts the nmcli d wifi list command. Configuring the phone (under the Config submenu) enables setting the brightness, enabling or disabling touch, gestures, and Bluetooth, as well as upgrading packages, among other things.

#### SMS messages and calls

[![[Sxmo receiving call]](https://static.lwn.net/images/2024/sxmo-call-sm.png "Sxmo receiving call")](https://lwn.net/Articles/981349/)

Sending an SMS message requires typing a phone number or selecting a person from the contact list first. Then the Vim-like text editor [vis](https://github.com/martanne/vis) is opened to compose the message. After the user exits the editor and confirms, the message is sent. An incoming SMS message briefly appears on the home screen; it can also be read later from the global system menu, where it's included in a Notifications menu item, and in the Texts submenu. Upon receipt of a new text message, the phone's LED emits a green light and the vibration motor momentarily triggers.

Calling uses a similar text-centric process. To place a new call, open the Dialer submenu in the global system menu and enter a phone number or choose an entry from the contact list. After selecting the number, Sxmo starts calling, and once the call connects, a menu appears with options to hang up the call, manage audio routing, and more. An incoming call triggers the phone's green LED and the vibration motor, and a menu appears that enables the user to accept or dismiss the call.

#### Mobile terminal

When no menu is active, a single tap on the volume-down button shows or hides the virtual keyboard at the bottom of the screen. This action can also be performed by swiping up and down from the bottom of the screen. One tap on the volume-up button launches an application-specific context menu for the currently focused window of a supported application. Three taps or holding the power button opens the terminal emulator. And three taps (or hold) on the volume-down button terminates the currently focused window.

Although working with terminal applications on a primarily touch-based device might not seem like a good match, Sxmo defines some one-finger swipe gestures that ease the experience. For example, swiping from left to right along the bottom edge sends a Return key to the application. Similarly, swiping from right to left along the bottom sends Backspace. Swiping top to bottom along the right edge sends an arrow-down key, while swiping bottom to top along the right edge sends an arrow-up key. Swiping right to left onto the left edge sends a left-arrow key, while swiping left to right onto the right edge sends a right-arrow key. These gestures allow the user to scroll through the shell history and the current command without the need to open the virtual keyboard and use up precious screen space. The virtual keyboard does not support swipe typing, however.

#### Plain-text files and shell scripts

Sxmo's configuration is entirely based on plain-text files. For example, contact details are stored in a tab-separated file in ~/.config/sxmo/contacts.tsv. This file has two columns: first the phone number, followed by the contact name. Contacts can be added either by manually editing the file or from the Contacts entry in the global system menu. Similarly, the ~/.config/sxmo/block.tsv file lists phone numbers and corresponding contact names that the user wishes to block.

Sxmo's behavior is defined in the ~/.config/sxmo/profile file, as well as in dozens of hooks, which are shell scripts with a specific name. For example, when the phone is receiving an incoming call, the shell script in /usr/share/sxmo/default_hooks/sxmo_hook_ring.sh is executed with the first argument ($1) set to the contact name or incoming number. This script can be overridden by the ~/.config/sxmo/hooks/sxmo_hook_ring.sh file if the user wants to change the default behavior. User scripts can also be added to the global system menu for custom functionality. The postmarketOS wiki hosts a [tips and tricks](https://wiki.postmarketos.org/wiki/Sxmo/Tips_and_Tricks) page for Sxmo, featuring some helpful advice and configuration snippets. For a deeper exploration under the hood, Sxmo's [system guide](https://man.sr.ht/~anjan/sxmo-docs/SYSTEMGUIDE.md) offers an excellent source of information.

#### Contributing to Sxmo

Much of Sxmo's core functionality is built upon shell scripts. While this allows complete customization, it requires some Linux and shell-scripting knowledge. The developers actively invite [contributions](https://man.sr.ht/~anjan/sxmo-docs-stable/CONTRIBUTING.md), especially for [device profiles](https://git.sr.ht/~mil/sxmo-utils/tree/master/item/scripts/deviceprofiles/README.md), which are shell scripts that Sxmo loads early on to set some attributes that ensure the devices work well with Sxmo.

Sxmo was originally designed for the PinePhone. Meanwhile, support for a few other devices has been added, including the Librem 5 and the Fairphone 4, but also the 15-year-old Nokia N900 with a physical keyboard and the Kobo Clara HD e-reader. Users trying to run Sxmo on an unsupported device can find some instructions to create a device profile in the sxmo-utils repository linked above. The result is a shell script that exports some environment variables for the touch-screen device, display output, screen scale, buttons, and more.

In the last two years, Sxmo has had eight [releases](https://lists.sr.ht/~mil/sxmo-announce/), slowing down a bit during the last year. The most recent was [Sxmo 1.16.1](https://lists.sr.ht/~mil/sxmo-announce/%3CD1QCSDN7DYIB.2R4TBAG9SVKDQ@willowbarraco.fr%3E) from June 3, which was a minor release. It had some tiny improvements in the control of the suspend functionality along with initial device profiles for PINE64's PineTab 2 tablet and Xiaomi's Redmi Note 4 phone. There's a [ticket list](https://todo.sr.ht/~mil/sxmo-tickets) tracking bugs and feature improvements, but it doesn't seem very active. The [sxmo-devel](https://lists.sr.ht/~mil/sxmo-devel) mailing list does get patches regularly for various repositories of the project.

With Sxmo's focus on delivering a minimalist environment, it is no surprise that the project doesn't intend to switch to systemd, as [postmarketOS has done](https://lwn.net/Articles/964574/). In the FAQ about the switch, the postmarketOS developers make it clear that [Sxmo will be sticking with OpenRC](https://postmarketos.org/blog/2024/03/05/adding-systemd/#what-about-openrc-s6-runit-dinit) for its init system.

#### Conclusion

Sxmo is even less suited for most users than postmarketOS. However, for tech-savvy, seasoned Linux users who want to have a lightweight and completely scriptable interface on their phone, Sxmo provides a different path from the conventional mobile user interfaces. It takes some time to adjust to the hardware buttons to control the phone's menu-based interface, but after some time, it works remarkably well.

[Comments (3 posted)](https://lwn.net/Articles/981320/#Comments)

### [Another try for getrandom() in the vDSO](https://lwn.net/Articles/980447/)

By **Jonathan Corbet**\
July 4, 2024

Random numbers, it seems, can never be random enough, and they cannot be generated quickly enough. The kernel's [getrandom()](https://man7.org/linux/man-pages/man2/getrandom.2.html) system call might, after years of discussion, be seen as sufficiently secure by most users, but it is still a system call. Linux system calls are relatively fast, but they are necessarily slower than calling a function directly. In an attempt to speed the provision of secure random data to user space, Jason Donenfeld has put together [an implementation of getrandom()](https://lwn.net/ml/all/20240703183115.1075219-1-Jason@zx2c4.com) that lives in the [virtual dynamic shared object (vDSO) area](https://man7.org/linux/man-pages/man7/vdso.7.html).

Random data is used in no end of applications, including modeling of natural phenomena, generation of identifiers like [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier), and game play; it's how [NetHack](https://www.nethack.org/) somehow summons those three balrogs all in one corner of a dark room. Security-related operations, such as the generation of nonces and keys, also make heavy use of random data — and depend heavily on that data actually being random. Some applications need so much random data that they spend a significant amount of time in the getrandom() system call.

One possible solution to this problem is to generate random numbers in user space, perhaps seeded by random data from the kernel; many developers have taken that route over the years. But, as Donenfeld explains in the cover letter to his patch series, that approach is not ideal. The kernel has the best view of the amount of entropy in the system and what is needed to generate truly random data. It is also aware of events, such as virtual-machine forks, that can compromise a random-number generator and make a reseeding necessary. He concluded:

> The simplest statement you could make is that userspace RNGs that expand a getrandom() seed at some point T1 are nearly always *worse*, in some way, than just calling getrandom() every time a random number is desired.

Always calling getrandom() ensures the best random data, but the associated performance problem remains. Moving that function into the vDSO can help to address that problem.

#### getrandom() in the vDSO

The vDSO is a special mechanism provided to accelerate tasks that require some kernel involvement, but which can otherwise be carried out just as well in user space. It contains code and data provided in user space directly by the kernel in a memory area mapped into every thread's address space. The classic vDSO function is [gettimeofday()](https://man7.org/linux/man-pages/man2/gettimeofday.2.html), which returns the current system time as kept by the kernel. This function can be implemented as a system call, but that will slow down applications that frequently query the time, of which there are many. So the Linux vDSO includes an implementation of gettimeofday(); that implementation can simply read a time variable in memory shared with the kernel and return it to the caller, avoiding the need to make a system call.

getrandom() is a similar sort of function; it reads data from the kernel and returns it to user space. So a vDSO implementation of getrandom() might make sense. Such an implementation must be done carefully, though; it should return data that is just as random as a direct call into the kernel would, and it must be robust against the types of events (a fork, for example) that could compromise the state of a thread's random-number generation.

In Donenfeld's implementation, user-space programs will continue to just call getrandom() as usual, with no changes needed. Under the hood, though, there are some significant changes needed within the C library, which provides the getrandom() wrapper for the system call.

#### State-area allocation

The random-number generator works on some state data stored in memory. When random data is needed, a pseudo-random-number generator creates it from that state, mutating the state in the process. Every thread must have its own state, and care must be taken to avoid exposing that state during events like process forks, core dumps, virtual-machine forks, or checkpointing. That state should be reseeded with random data regularly, and specifically at any time when its content might have been compromised.

The vDSO implementation of getrandom() requires that the memory to be used for this state be allocated by the kernel. So the first thing that the C library must do is to allocate this state storage for as many threads as it thinks are likely to run. That is done with a new system call:

```
struct vgetrandom_alloc_args {
    u64 flags;
  	u64 num;
  	u64 size_per_each;
  	u64 bytes_allocated;
};

void *vgetrandom_alloc(struct vgetrandom_alloc_args *args, size_t args_len);
```

The structure pointed to by args describes the allocation request, while args_len is sizeof(\*args); that allows the structure to be extended in a compatible way if needed in the future. Within that structure, flags must currently be zero, and num is the number of thread-state areas that the kernel is being requested to allocate. On a successful return, num will be set to the number of areas actually allocated, size_per_each describes the size of a state area, and bytes_allocated is the total amount of memory that was allocated. The return value will point to the base of the allocated area.

The allocated area is ordinary anonymous memory, except that it will be specially marked within the kernel using a number of virtual-memory-area flags. The VM_WIPEONFORK flag causes its contents to be zeroed if the process forks (so that the two processes do not generate the same stream of random numbers), VM_DONTDUMP keeps its contents from being written to core dumps, and VM_NORESERVE causes it to not be charged against the process's locked-memory limit. Donenfeld also added a new flag to use with this area: VM_DROPPABLE allows the memory-management subsystem to simply reclaim the memory if need be; since this is anonymous memory, accessing it after it is reclaimed will cause a new, zero-filled page to be allocated. The result is memory that should remain private, but which can be zeroed (or reclaimed, which has the same effect) by the kernel at any time.

#### Generating random data

The kernel also shares some memory with the vDSO containing this structure:

```
struct vdso_rng_data {
u64	generation;
u8	is_ready;
};
```

This structure is used by the vDSO version of getrandom(), which has this prototype:

```
ssize_t vgetrandom(void *buffer, size_t len, unsigned int flags,
                   void *opaque_state, size_t opaque_len);
```

The first three arguments mirror getrandom(), describing the amount of random data needed and whether the call should block waiting for the kernel's random-number generator to be ready. The final two, instead, describe one of the state areas allocated by vgetrandom_alloc(). This function's job is to provide the same behavior that getrandom() would.

It starts by looking at the is_ready field in the shared structure; if the kernel's random-number generator is not yet ready, vgetrandom() will just call getrandom() to handle the request. Once the random-number generator has initialized, though, that fallback will no longer be necessary. So the next thing to do is to compare the generation count (which tracks the number of times that the kernel's random-number generator has been reseeded) with a generation count stored in the state area. If the two don't match, then the state area must be reseeded with random data obtained from the kernel.

When the state area is first allocated, it is zeroed, so the generation number found there will be zero, which will never match the kernel's generation number; that will cause the state area to be seeded on the first call to vgetrandom(). The same thing will happen if this area has been cleared by the kernel, as the result of a fork (VM_WIPEONFORK) or the memory being reclaimed (VM_DROPPABLE), for example. So the kernel is able to clear that memory at any time in the knowledge that vgetrandom() will do the right thing.

Once the state area is known to be in a good condition, vgetrandom() uses it to generate the requested random data using the same algorithm used within the kernel itself. Doing this calculation securely is a bit tricky; if the process forks or core-dumps while it is underway, any data kept on the stack could be exposed. So vgetrandom() has to use an implementation of the [ChaCha20 stream cipher](https://datatracker.ietf.org/doc/html/rfc7539) that uses no stack at all. The patch series only includes an x86 implementation of this cipher; other architectures seem certain to follow.

As a final step before returning the generated data to the caller, vgetrandom() checks the generation number one more time. If, for example, the state area was wiped by the kernel while the call was executing, the generation-number check will fail. In such cases, vgetrandom() will throw away its work and start over.

Donenfeld described the end result of this work as "pretty stellar (around 15x for uint32_t generation)" and noted happily that "it seems to be working".

#### Prospects

LWN last [looked at this work](https://lwn.net/Articles/919008/) at the beginning of 2023. At that time, there were a number of objections, many of which were focused on the VM_DROPPABLE changes to the memory-management subsystem, which included some tricky, x86-specific tricks. When [version 15](https://lwn.net/ml/linux-kernel/20240521111958.2384173-1-Jason@zx2c4.com/) of the patch series was posted several months later, VM_DROPPABLE remained, but the logic had been simplified considerably in the hope of addressing those concerns, seemingly successfully. There does not appear to be anybody who is arguing against the inclusion of this series now.

As of the current version (20), this work has been added to linux-next for wider testing; if all goes well, it could go upstream as soon as the 6.11 merge window later this month. "If all goes well", of course, includes passing muster with Linus Torvalds, who has not commented this time around; he was [not thrilled](https://lwn.net/ml/linux-kernel/CAHk-=wg_6Uhkjy12Vq_hN6rQqGRP2nE15rkgiAo6Qay5aOeigg@mail.gmail.com/) with previous versions, though. Should the mainline merge happen, the work to integrate the needed changes into the C libraries can begin. The end result will be a significant internal change, but the only thing that users should notice is that their programs run faster.

[Comments (25 posted)](https://lwn.net/Articles/980447/#Comments)

### [Offload-friendly network encryption in the kernel](https://lwn.net/Articles/980430/)

By **Daroc Alden**\
July 9, 2024

The [PSP security protocol](https://github.com/google/psp) (PSP) is a way to transparently encrypt packets by efficiently offloading encryption and decryption to the network interface cards (NICs) that Google uses for connections inside its data centers. The protocol is similar to [IPsec](https://en.wikipedia.org/wiki/IPsec), in that it allows for wrapping arbitrary traffic in a layer of encryption. The difference is that PSP is encapsulated in UDP, and designed from the beginning to reduce the amount of state that NICs have to track in order to send and receive encrypted traffic, allowing for more simultaneous connections. Jakub Kicinski [wants to add support](https://lwn.net/ml/netdev/20240510030435.120935-1-kuba@kernel.org/) for the protocol to the Linux kernel.

#### The protocol

PSP is a fairly minimal protocol. It completely avoids the topic of how to do a secure key exchange, assuming that the applications on either end of a connection will be able to exchange symmetric-encryption keys somehow. This is not an unreasonable design decision, since IPsec does the same thing. There are several existing protocols for securely exchanging keys, such as [Internet Key Exchange](https://en.wikipedia.org/wiki/Internet_Key_Exchange) or [Kerberized Internet Negotiation of Keys](https://en.wikipedia.org/wiki/Kerberized_Internet_Negotiation_of_Keys). Usually, those protocols are indifferent to the source of the symmetric keys. PSP is a bit different. To support hardware-offload, PSP requires that the NIC itself generate the keys for a PSP connection. The PSP [architecture specification](https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf) goes into detail about how NICs should do that.

The main requirement is that the NIC should be able to rederive the key for a session from a fairly limited amount of information — specifically, from a 32-bit "Security Parameter Index" (SPI) value and a secret key stored on the device. That key is generated by the NIC and used to derive the session-specific encryption key for each connection as needed, using a secure key-derivation function. Therefore, the SPI alone is not enough to decrypt a packet; this allows SPIs to be included in PSP packets, letting the NIC rederive the encryption key for a packet on the fly. In turn, this means that the NIC does not actually need to store an encryption key in order to receive and process a packet, greatly reducing the amount of memory necessary on the device.

Unfortunately, this requirement to rederive keys comes at a price — PSP connections are unidirectional. For real use cases where bidirectional communication is required, the application needs to set up a separate PSP connection for each direction. Since rederiving the key requires access to a device key stored on the NIC, only the receiving NIC can rederive it, so the transmitting device still needs to store the key somewhere. While that could be on the NIC, the PSP specification leaves open the possibility of a hardware implementation that requires the computer to send the encryption key to the NIC alongside any transmitted packets.

To encrypt packets, PSP uses AES-128-GCM or AES-256-GCM. These are both [authenticated encryption with associated data](https://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data) (AEAD) schemes — they guarantee that the received data has not been tampered with (authentication) and bundle some encrypted data alongside some associated plain-text data. In PSP's case, this is used to implement an offset that allows the sender to leave the headers of a protocol encapsulated in PSP unencrypted, while still protecting the contents. Supporting only two modes of AES keeps the implementation complexity of PSP low.

PSP also has a packet layout designed to make parsing the packet in hardware more efficient, by providing explicit lengths in the header and using fewer optional headers than IPsec does. In combination with the unique key-derivation scheme, PSP ends up being more hardware-implementation-friendly than other encryption protocols like IPsec or TLS.

While Google is both the originator and largest current user of PSP, the protocol could potentially be useful to other users. Compared to other encrypted protocols, PSP requires a lot less on-device memory, letting it scale to larger numbers of connections. Because the protocol doesn't mandate a key-exchange standard, PSP is probably a good choice for an environment where the user controls both ends of the connection, but still wants to ensure that traffic can be encrypted.

#### The discussion

Despite how useful Google finds the protocol, kernel developers were dubious about adding yet another encryption protocol to the kernel, which already handles IPsec, WireGuard, TLS, and others. Paul Wouters [expressed surprise](https://lwn.net/ml/netdev/1da873f4-7d9b-1bb3-0c44-0c04923bf3ab@nohats.ca/) that Kicinski wanted to add PSP to the kernel, when the IETF had declined to standardize the protocol on the basis that it is too similar to IPsec.

Steffen Klassert [shared](https://lwn.net/ml/netdev/ZlWm/rt2OGfOCiZR@gauss3.secunet.de/) a [draft](https://datatracker.ietf.org/doc/draft-klassert-ipsecme-wespv2/) that the IPsecME working group has been putting together that covers some of the same use cases as PSP. That may not be as helpful as it sounds, however, because there are already hardware devices implementing PSP, Willem de Bruijn [pointed out](https://lwn.net/ml/netdev/6655e0eecb33a_29176f29427@willemb.c.googlers.com.notmuch/). "It makes sense to work to get to an IETF standard protocol that captures the same benefits. But that is independent from enabling what is already implemented."

That answer [didn't satisfy Wouters](https://lwn.net/ml/netdev/81646030-00b9-10ad-abed-a7a78f0c511e@nohats.ca/), who asked: "How many different packet encryption methods should the linux kernel have?" He said that waiting for protocols to be standardized provides interoperability, and chances to make sure a protocol is actually useful for more than one use case. PSP and IPsec can also use a lot of the same NIC hardware, he pointed out.

"I don't disagree on the merits of a standards process, of course. It's just moot at this point wrt PSP", de Bruijn [replied](https://lwn.net/ml/netdev/66561e53a11be_2a1fb929472@willemb.c.googlers.com.notmuch/). Klassert [agreed](https://lwn.net/ml/netdev/ZllpgEvQ4QnfP3m7@gauss3.secunet.de/) that existing PSP users need to be supported, but thought that it was still important to work on standardizing a modern encryption protocol that meets everyone's needs. He invited Google to send representatives to the IETF IPsecME working group meeting to discuss the topic. De Bruijn [said that the company would](https://lwn.net/ml/netdev/6659e2d5cd07e_3fde492947a@willemb.c.googlers.com.notmuch/).

But some reviewers also had technical objections to Kicinski's patch set. The API he proposed allows user space to set a PSP encryption key on a socket, after which data transmitted through that socket will be encrypted. The problem is how exactly this interacts with retransmissions. PSP is encapsulated in UDP, and has no guarantee that data will arrive intact or in order, leaving that detail up to higher-level protocols. But Kicinski is mainly interested in PSP as a TLS replacement — which of course runs on top of TCP. PSP supports wrapping TCP, but just by encrypting individual packets, not by participating in TCP's retransmission logic.

Together, this creates some edge cases, de Bruijn [pointed out](https://lwn.net/ml/netdev/66416bc7b2d10_1d6c6729475@willemb.c.googlers.com.notmuch/). How is the kernel supposed to handle retransmissions of plain-text data after a PSP key has been associated with a socket? "Like TLS offload, the data is annotated 'for encryption' when queued. So data queued earlier or retransmits of such data will never be encrypted", Kicinski [explained](https://lwn.net/ml/netdev/20240529103505.601872ea@kernel.org/).

De Bruijn [wasn't completely satisfied](https://lwn.net/ml/netdev/6657cc86ddf97_37107c29438@willemb.c.googlers.com.notmuch/) with that, pointing out that it still leaves edge cases. What happens if one peer upgrades the connection at the same time the other peer decides to drop it? "If (big if) that can happen, then the connection cannot be cleanly closed." In response, Kicinski [suggested](https://lwn.net/ml/netdev/20240530125120.24dd7f98@kernel.org/) "only enforcing encryption of data-less segments once we've seen some encrypted data". De Bruijn [agreed](https://lwn.net/ml/netdev/6659d71adc259_3f8cab29433@willemb.c.googlers.com.notmuch/) that might help, but was still worried that the kernel API could still be used in ways that break the correctness of the protocol, and suggested that some more thorough documentation might be appropriate.

In response, Kicinski [put together](https://lwn.net/ml/netdev/20240604170849.110d56c1@kernel.org/) some sequence diagrams showing how a PSP-secured socket is set up and torn down. De Bruijn [thought](https://lwn.net/ml/netdev/6660c673921ff_35916d294ef@willemb.c.googlers.com.notmuch/) that was a substantial improvement, but remained unconvinced that all of the edge cases had been handled.

Lance Richardson [raised](https://lwn.net/ml/netdev/CAHWOjVJ2pMWdQSRK_DJkx7Q9zAzLx6mjE-Xr3ZqGzZFUi5PrMw@mail.gmail.com/) some questions about the kernel API as well, noting that there didn't seem to be any real support for rekeying a socket, something that PSP mandates every 24 hours. In a [follow-up message](https://lwn.net/ml/netdev/CAHWOjVL2hM4Lv=jNAv9CmLHYJL5ZBHmDH=ySQr7fr1Z6kgAvjg@mail.gmail.com/), Richardson suggested that it might be as simple as keeping an old key around for a minute or two after rekeying. Kicinski [agreed that made sense](https://lwn.net/ml/netdev/20240628164152.34b69c01@kernel.org/), and promised to add it to the next version of the patch set.

While there are lots of reasons to use PSP, and the presence of hardware that supports it is a good sign, the lack of a standard and questions around the implementation suggest that it may be some time before support is finalized. Still, in the future we could see yet another encryption protocol come to the kernel. The exact details of how that happens remain to be seen.

[Comments (15 posted)](https://lwn.net/Articles/980430/#Comments)

### [A new API for tree-in-dcache filesystems](https://lwn.net/Articles/980558/)

By **Jake Edge**\
July 9, 2024

______________________________________________________________________

[LSFMM+BPF](https://lwn.net/Articles/lsfmmbpf2024/)

There are a number of kernel filesystems that store their directory entries directly in the directory-entry cache (dcache) without having any permanent storage for those objects. It started out as a "neat hack" for [ramfs](https://docs.kernel.org/filesystems/ramfs-rootfs-initramfs.html), Al Viro said, at the start of his filesystem-track session at the 2024 [Linux Storage, Filesystem, Memory Management, and BPF Summit](https://events.linuxfoundation.org/lsfmmbpf/). Unfortunately, as the use of this technique has grown into other filesystems, there has been a lot of scope creep that has gotten out of control. He wanted to discuss some new infrastructure that he is working on to try to clean some of that up.

[![[Al Viro]](https://static.lwn.net/images/2024/lsfmb-viro-sm.png "Al Viro")](https://lwn.net/Articles/981165/)

Viro displayed some [notes](https://ftp.linux.org.uk/pub/people/viro/notes) on his thoughts to accompany his talk; some of this article derives from those notes. He has a patch set to implement those ideas (contained in his ["untested.persistency" branch](https://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs.git/log/?h=untested.persistency)) that is "very much a work in progress", which is untested and may not compile on anything other than x86, he said. He wanted to describe the problem it is meant to solve and how it does so.

It all started with a demonstration by Linus Torvalds of how to create a filesystem without a backing store, he said. The technique kept all of the files and directories in the cache and was the basis for ramfs. A "controlled dentry \[directory entry\] leak" was used; reference counts are artificially increased to ensure that the directory entries do not get evicted. When an unmount is done, they are all cleaned up.

The technique was adopted by tmpfs, hugetlbfs, and in other places, because it is simpler than what procfs uses. There are problems that arise in some of the other users, however, that do not exist in the original. The original intent was only for filesystems that were being populated from user space, but eventually it was used for filesystems that are populated by the kernel, or, perhaps worse, both the kernel and user space.

For example, [rmdir()](https://man7.org/linux/man-pages/man2/rmdir.2.html) only removes directories that are empty, but the configfs user-space tools expect the system call to be able to remove a populated subtree if all of its entries were created by the kernel. If there are user-created subdirectories, the tools expect the rmdir() to fail. Christian Brauner pointed out that the control-group filesystem (cgroupfs) also has this behavior. Viro said that filesystems of this sort have to implement their own rmdir() because it is so specialized. For configfs, it needs to check if there have been any directories created by the user inside the target—or any that are in progress. The code "is horrible", he said.

There is a real need for some infrastructure to help these filesystems, Viro said. There are around a dozen different implementations of the subdirectory-removal handling, none of which have been done correctly. His idea is to introduce a flag, DCACHE_PERSISTENT that will be used to mark the dentries that are being "controllably leaked" so that they can be properly handled. Then the kernel-initiated operations and those from user space can set the flag, so that they are handled in the same way, which is not the case right now.

There would be two new functions that would be the counterparts to [dget()](https://elixir.bootlin.com/linux/v6.9.8/source/include/linux/dcache.h#L312) and [dput()](https://elixir.bootlin.com/linux/v6.9.8/source/fs/dcache.c#L824) (which obtain and release references to directory entries); d_make_persistent() would do the equivalent of dget() and set the flag, while d_make_discardable() will do a dput() and clear it. There are new helper functions to handle both the simple filesystems like ramfs and the more complicated varieties, including handling some of the variations of open-coded directory-removal code. There are more details in the notes file.

There are still four filesystems that remain to be converted, Viro said. They all have "interesting problems" that need to be resolved; two of them are for [USB gadgets](https://www.kernel.org/doc/html/v4.17/driver-api/usb/gadget.html), one is configfs, and the other is apparmorfs. The diffstat of his patch set shows that the changes would actually result in a net removal of around 500 lines of code from the tree.

He had hoped to discuss configfs with Christoph Hellwig, who was not present, though he did arrive later in the day. He plans to talk to Greg Kroah-Hartman about the USB-gadget filesystems, but is not sure who to talk to about apparmorfs. There is some strange locking being done in apparmorfs, which he mentioned to the AppArmor developers, but got nowhere, he said. There was some further discussion on this and related work as time ran out on the session.

[Comments (2 posted)](https://lwn.net/Articles/980558/#Comments)

### [Improving pseudo filesystems](https://lwn.net/Articles/981155/)

By **Jake Edge**\
July 10, 2024

______________________________________________________________________

[LSFMM+BPF](https://lwn.net/Articles/lsfmmbpf2024/)

The eventfs filesystem provides an interface to the tracepoints that are available to be used by various Linux tracing tools (e.g. ftrace, perf, uprobes, etc.); it is meant to be a version of the tracefs filesystem that dynamically allocates its entries as needed. The goal is to reduce the memory required for multiple instances of tracefs, as Steven Rostedt described in a [session](https://lwn.net/Articles/895111/) at the 2022 [Linux Storage, Filesystem, Memory Management, and BPF Summit](https://events.linuxfoundation.org/lsfmmbpf/). He returned to the 2024 edition of the summit to talk further about how to make pseudo (or virtual) filesystems, such as tracefs/eventfs, more like regular Linux filesystems, where the directory entries (dentries) and inodes are only created (and cached) as needed.

#### Background

He began with some background on eventfs; it is based on tracefs, which was itself based on [debugfs](https://docs.kernel.org/filesystems/debugfs.html). Because of the interface that debugfs provides, eventfs maintained dentries for each of its files and directories. Around the same time that Rostedt [proposed a session on virtual filesystems](https://lwn.net/ml/linux-mm/20240125104822.04a5ad44@gandalf.local.home/) for this year, eventfs was [being extensively reworked](https://lwn.net/Articles/960088/) to avoid a number of problems, some of which were security related. As part of that, Linus Torvalds made it clear (in his inimitable way) that a dentry-centric approach was not right.

[![[Steven Rostedt]](https://static.lwn.net/images/2024/lsfmb-rostedt-sm.png "Steven Rostedt")](https://lwn.net/Articles/981390/)

At the session in 2022, Christian Brauner had suggested using [kernfs](<https://en.wikipedia.org/wiki/Kernfs_(Linux)>) as the basis for eventfs. When Rostedt looked at that, he saw that only sysfs and control groups used kernfs, and it did not look like it applied to what he was trying to do. After playing with it more recently, he can see that it might make sense to convert all of debugfs and tracefs to use kernfs, but it will not work for eventfs, he said.

One of the things he is working on is tracing infrastructure for Chromebooks, some of which have only 2GB of RAM; "memory is very much a hot commodity there". There are "thousands and thousands of files" in eventfs; new instances of eventfs create a new ring buffer, but they also duplicate most of the files, which uses a lot of memory. So, eventfs was turned into a dynamic filesystem that did not create dentries and inodes until they were actually needed, which provided substantial memory savings.

The crux of the disagreement with Torvalds is based in Rostedt's lack of understanding of how filesystems are supposed to be implemented, coupled with the API for debugfs. Torvalds asked Rostedt why dentries were being created for eventfs before the filesystem was even mounted. Creating a file with [debugfs_create_file()](https://elixir.bootlin.com/linux/v6.9.8/source/fs/debugfs/inode.c#L457) returns a dentry, however, so Rostedt thought that was the way it should be done. Al Viro pointed out that eventfs went far beyond what debugfs had ever done, though, which "was really scary"; he is "not fond" of what debugfs does, but eventfs took things much further. Things are "much saner" after the fixes that went into eventfs, Viro said.

Rostedt said that now that he has learned more, he is concerned that debugfs needs attention; "maybe we should update it". Viro noted that debugfs has some object-lifetime problems as well as a lack of "sane exclusion" when doing I/O on files that are being removed. Rostedt wondered if debugfs should be switched to using kernfs, but Viro said that "kernfs has different issues".

Kernfs is not fully namespace-aware for one thing, Viro said. Brauner suggested that debugfs did not need namespace support, but Rostedt and Viro said that people want to be able to mount debugfs inside containers. "That's insane on the face of it", Brauner said; "we are not going to do this".

One of the problems that he has encountered, Rostedt said, is that developers start by using debugfs for some project, but that once it gains some traction, they want to move it to its own filesystem. Debugfs is not really a good basis for that as it stands. That's what happened to him; "I'm here to say, let's not have someone else follow my steps". For that reason, he thinks debugfs should be switched to a better interface that people can use as a basis for their filesystems.

#### The path?

After some discussion between Brauner and Viro about the current status of debugfs, Rostedt shifted gears slightly and asked what the proper path is for kernel developers who want to move their filesystems from debugfs to a real filesystem. Viro reiterated some of the concerns he has with debugfs, including the ability for applications to continue reading from open file descriptors after the debugfs file has been removed.

Rostedt wondered about the use of dentries in the debugfs interface; he thought that there might well be memory concerns for those who are mounting it. Brauner said that there is no real control over how many files there are in debugfs, since any random driver can add entries whenever it wants. Writing to one of those files might deadlock or crash the system. For those and other reasons, "mounting debugfs on a production system is ... adventurous".

Dave Chinner said that Rostedt was asking the wrong question. Starting with debugfs and then trying to move that code to a production filesystem is wrong. If it is destined for production, it should be developed within sysfs, but Rostedt noted that sysfs is restrictive; sysfs files are supposed to only have a single value. Chinner said that the restriction was often ignored.

Developers who are not filesystem-focused choose debugfs as a starting point because it is easy to do so, Rostedt said; they are typically just doing it for debug purposes in the early going. Then the functionality turns out to be useful, but now the code has been built around debugfs, which is "not the way to do it", he said.

"Ask the experts", Chinner suggested, but Rostedt said that "a lot of times the experts are busy doing their own thing". He had posted versions of his work along the way, he said, but rarely got any comments from the experts.

Brauner and Viro talked about some approaches that might scale reasonably for the eventfs use case, but did not really come to a conclusion. Part of the problem, Ted Ts'o said, is that "there is no one general solution" to point kernel developers at; debugfs is perfectly fine for a small number of files and when just a single instance is needed. For situations with multiple instances and millions of files, there is no existing code to point to. So it is not possible to give advice that pertains to all of the possible filesystems that may be needed.

But Rostedt said that he was not trying to solve the eventfs problem—it is a specialized use case—but wanted to figure out what to tell developers who want to move a fairly simple debugfs-based filesystem to a real filesystem. Brauner said that there are some questions that need to be answered first: is there a single instance of the filesystem or does each mount create a new one? Does the filesystem need to be namespace-aware? Without those answers, it is difficult to say what the proper path might be.

As time was running down, Rostedt said that what was being said in the session "was like gold to me". He thinks that what was discussed needs to be fully documented and that the questions that need to be answered are obviously a big part of that. Viro said that sounded like a "frequently asked questions" document, which elicited some laughter. Rostedt agreed, though, and asked if there was any documentation of that sort. Brauner said that there was not, "and I think that is a fair point"; for example, most filesystems these days will need to be namespace-aware but there are not really good examples to point developers to. Whether that will result in documentation patches was not clear, however.

[Comments (none posted)](https://lwn.net/Articles/981155/#Comments)

### [Giving bootloaders the boot with nmbl](https://lwn.net/Articles/979789/)

By **Joe Brockmeier**\
July 8, 2024

______________________________________________________________________

[DevConf.cz](https://lwn.net/Archives/ConferenceByYear/#2024-DevConf.cz)

At [DevConf.cz 2024](https://www.devconf.info/cz/), Marta Lewandowska gave a talk to discuss a new approach for booting Linux systems, "[No more boot loader: Please use the kernel instead](https://pretalx.com/devconf-cz-2024/talk/W3AVCT/)". The talk, [available on YouTube](https://www.youtube.com/watch?v=ywrSDLp926M), introduced a new project called nmbl (for "no more bootloader", pronounced "nimble"). The idea is to get rid of bootloaders (e.g., [GNU GRUB](https://www.gnu.org/software/grub/)) with a [Unified Kernel Image](https://uapi-group.org/specifications/specs/unified_kernel_image/) (UKI) that removes the need for a separate bootloader altogether. It is early days for nmbl, currently the project is only being tested for use with virtual machines, but the idea is compelling. If successful, nmbl could offer security, performance, and maintenance benefits compared to GRUB and other separate bootloaders.

#### Rationale

Longtime Linux users have seen their share of bootloaders, the software that initializes hardware and loads the operating system, over the years. In the earliest days, users might have used [loadlin](https://en.wikipedia.org/wiki/Loadlin) to boot into Linux from MS-DOS. Then there was [Linux Loader](https://wiki.debian.org/LILO) (LILO). It was the popular choice for Linux distributions until the mid-2000s, when Linux distributions began switching to the [GRand Unified Bootloader](https://wiki.debian.org/Grub) (GRUB), and then [GRUB 2](https://wiki.debian.org/GRUB2) (which has supplanted GRUB legacy, so we will just say "GRUB" after this). The [SYSLINUX](https://wiki.syslinux.org/wiki/index.php?title=SYSLINUX) family of bootloaders was a popular choice for booting from floppies, CD-ROMs ([ISOLINUX](https://wiki.syslinux.org/wiki/index.php?title=ISOLINUX)), network servers using PXE boot ([PXELINUX](https://wiki.syslinux.org/wiki/index.php?title=PXELINUX)), and a variety of filesystems ([EXTLINUX](https://wiki.syslinux.org/wiki/index.php?title=EXTLINUX)). That is not an exhaustive list, merely a sampling of more widely used bootloaders on x86/x86_64 systems. Other platforms required their own bootloaders, of course.

Lewandowska, a quality engineer at Red Hat, started her talk with a discussion of the purpose of the bootloader and things that can go wrong. The bootloader, she said, is the first piece of software that runs and "gets everything ready for booting and getting the operating system running" and then transfers control to the kernel.

That may not sound like a big deal when booting a desktop or laptop system, she said, but it becomes much more complicated for multiple architectures, complex storage schemes, and booting over the network. All of those things have to be possible, and "all of those of you who have filed bugs with us know" it can go wrong in many ways.

On top of that, there is secure boot. The idea of secure boot, of course, is to ensure that a machine "doesn't have any malware from the beginning" she said. The chain of trust starts with hardware that will only load a trusted bootloader, which will only load a trusted kernel. Lewandowska explained briefly how this works with UEFI and Linux systems. When the system starts, its firmware will load a first-stage bootloader, called the [shim](https://github.com/rhboot/shim), if it has a trusted signature. Then it will load a signed bootloader, in this case GRUB. Next, GRUB will provide a menu of boot options and/or allow the user to edit boot options. Then GRUB will verify the selected kernel's signature with a protocol installed by the shim. GRUB also has to load the [initramfs](https://wiki.debian.org/initramfs), the initial root filesystem image used for booting the kernel, which Lewandowska said is "the biggest security hole" because it is not signed.

GRUB is great, she said, but it is also complex and needs to handle a lot of functionality that is duplicated in the Linux kernel. And, of course, it has security vulnerabilities too. She showed a slide with a list of 15 CVEs for GRUB since 2021. (Slides [here](https://pretalx.com/media/devconf-cz-2024/submissions/W3AVCT/resources/nmbl_devconf_official_2024_YWjkEyN.odp).) There has been only one in 2024, so far, but "believe me, more are coming" Lewandowska said. In addition to the CVEs there are plenty of regular bugs in GRUB such as filesystem, storage, and memory-allocation bugs that are difficult to solve and that those working with GRUB don't have the resources to fix. GRUB is not as actively developed as the Linux kernel is, so things are fixed more slowly. She noted that Red Hat was carrying "hundreds of downstream patches" for GRUB. "We're trying to fix all this, but it's a huge task and it goes slowly." That finally brings us to nmbl, she said.

#### Why nmbl

The idea for nmbl is "taking a whole bunch of things that have already existed" in Linux, adding a bit of code, and putting them together, Lewandowska said. Nmbl is delivered as a UKI: a single image in Portable Execution / Common Object File Format (PE/COFF) format that bundles the kernel image and resources needed to boot. Nmbl includes the kernel command line, an initramfs, the kernel, and UEFI stub (using [systemd-stub](https://www.freedesktop.org/software/systemd/man/latest/systemd-stub.html)) wrapped up as a UEFI executable that can be run from the UEFI firmware. As a bonus, nmbl can be signed so "now the whole thing becomes secure", including the initramfs.

Most of this is already in Fedora, she said. Fedora has [Dracut](https://fedoraproject.org/wiki/Dracut) for generating initramfs images, and has been adding support for UKIs. (LWN has covered [Fedora's plans for UKIs](https://lwn.net/Articles/918909/), and the progress toward [UKI support in Fedora 40](https://lwn.net/Articles/969145/).) Nmbl also uses [grub-emu](https://manpages.ubuntu.com/manpages/trusty/man1/grub-emu.1.html) to provide a GRUB-style menu that is already familiar for Linux users.

In a [blog post](https://fizuxchyk.wordpress.com/2024/06/13/nmbl-we-dont-need-a-bootloader/) timed to accompany the talk, she explained the advantages that nmbl might offer. First is improved boot time. Currently there are two variants of nmbl being worked on, one that provides direct booting of the desired kernel, and another that allows the user to boot into different kernels. The direct-boot option loads the same kernel used by nmbl and performs a [switch root](https://man7.org/linux/man-pages/man8/switch_root.8.html) to switch from the initrfamfs to the user-space filesystem. The other option loads the nmbl UKI and uses grub-emu to display the menu of bootable kernels. Then it uses [kexec](https://man7.org/linux/man-pages/man8/kexec.8.html) to boot the final kernel and bring up the system. When nmbl is the target kernel, it would substantially decrease boot time since there is no need to boot a second kernel.

It will also speed up feature delivery, says Lewandowska. "Since kernel and bootloader code will no longer have to be duplicated, features will only have to be implemented once to be available in both places." In addition, she wrote that implementing features once will reduce duplicate work and worries that things like kernel filesystem drivers would change. Since the bootloader and kernel would be "one and the same", any kernel changes would be immediately available to the bootloader as well.

She also touted the idea of increased security. Including all of the initramfs into a signed binary would "considerably increase security" she wrote. On top of that, nmbl would significantly reduce the attack surface "since the new code comprising nmbl is only several hundred lines of code compared to GRUB's hundreds of thousands". Finally, Lewandowska said that since the Linux kernel has a much larger community, nmbl would receive more scrutiny than GRUB does on its own.

#### Early days

There is still a lot of work to be done, Lewandowska said. The next thing that nmbl developers want to do is to build nmbl with every Fedora kernel build. Another feature on the horizon is shim A/B booting, which would allow fallback to the previous nmbl kernel if the newest one fails for some reason. This would make failed upgrades easier to recover from. The [proof-of-concept](https://github.com/rhboot/nmbl-poc) (POC) for nmbl right now runs on UEFI. Longer-term, the team wants to get nmbl working on other architectures that do not use UEFI as well.

Support for bare metal is also on the wish list. During the Q&A of her talk, Lewandowska said that development and testing of nmbl is primarily being done with virtual machines at the moment. It has been tested on hardware, she said, but not recently. She has posted [instructions](https://fizuxchyk.wordpress.com/2024/06/13/how-build-and-boot-nmbl-on-a-fedora-virtual-machine/) on how to do this in a virtual machine with Fedora 39, including guidance on how to generate a signing certificate and enroll the key to use secure boot with the nmbl UKI.

It will likely be years before nmbl is ready to supplant GRUB as the bootloader of choice for most Linux users, but it's an interesting approach that could have a lot of advantages if it succeeds.

[Comments (54 posted)](https://lwn.net/Articles/979789/#Comments)

**Page editor**: Jonathan Corbet

## Inside this week's LWN.net Weekly Edition

- [Briefs](https://lwn.net/Articles/980656/): OpenSSH vulnerability; Fedora Atomic boot problem; Text rendering; Firefox 128.0; GDB 15.1; Quotes; ...
- [Announcements](https://lwn.net/Articles/980657/): Newsletters, conferences, security updates, patches, and more.

**Next page**: [Brief items>>](https://lwn.net/Articles/980656/)

Copyright © 2024, Eklektix, Inc.\
Comments and public postings are copyrighted by their creators.\
Linux is a registered trademark of Linus Torvalds
