# 

原创 微信号szyhb1981 Linux驿站

 _2021年12月08日 19:10_

x86_64架构的Linux内核打印的函数调用链，有些函数名称的前面带有问号。经常有人问函数名称前面的问号表示什么意思。内核文档“Documentation/x86/kernel-stacks”解释了原因，如下。

我们总是从栈顶到栈底扫描整个内核栈，获取在内核栈上存储的返回地址，打印看起来像内核代码地址的任何内容。

如果获取的返回地址匹配帧指针链，那么我们打印函数名称，不添加“?”，表示这个函数是真实的栈回溯的一部分。

如果获取的返回地址不匹配帧指针链，那么仍然打印它，但是打印一个“?”，它可能表示2种意思，如下。

（1）这个返回地址不是调用链的一部分，它仅仅是早期的函数调用在内核栈上留下的旧值。这是常见的情况。

（2）或者这个返回地址是调用链的一部分，但是函数没有正确地设置帧指针，可能是因为编译器优化代码的时候省略帧指针，也可能是因为程序员使用汇编语言实现函数的时候没有设置帧指针。

这种方法最重要的特点是不会丢失信息：总是努力打印内核栈上看起来像内核代码地址的所有地址，所以如果调试信息是错误的，仍然会打印出真实的调用链，只是比理想情况多了一些问号。

  

x86_64架构的Linux内核支持下面这些栈回溯方法。

（1）**猜测回溯法**。扫描栈，每次读取一个8字节数据，如果数据属于代码段的虚拟地址范围，就把它当作指令地址。优点是没有运行时的开销，不会增加代码段的长度，不会导致程序性能下降；缺点是经常误报，如果某个局部变量的值属于代码段的虚拟地址范围，会把它当作指令地址。

（2）**帧指针回溯法**。优点是速度快，内存消耗比ORC回溯法小；缺点是代码段的长度增加大约3%，程序性能下降5%~10%。

（3）**ORC**（Oops Rewind Capability，死机回放功能）**回溯法**。4.14版本开始支持ORC回溯法。优点是和帧指针回溯法相比更准确，程序性能提高5%~10%；缺点是内存消耗比较大。

  

如果编译内核时打开配置宏CONFIG_UNWINDER_ORC，那么使用ORC展开器进行栈回溯。ORC展开器是内核社区自创的栈回溯方法，使用自定义的ORC展开表，ORC展开表是DWARF调用帧信息的简化版本。GCC编译器不支持生成ORC展开表，编译内核的时候使用内核自带的objtool工具生成ORC展开表。

如果编译内核时打开配置宏CONFIG_UNWINDER_FRAME_POINTER，那么使用帧指针展开器进行栈回溯。假设函数a调用函数b，栈帧的结构如图1所示，rbp寄存器存放函数栈帧的上边界，rsp寄存器存放函数栈帧的下边界，从虚拟地址“rbp + 8”可以获取返回地址，从rbp寄存器存放的虚拟地址可以获取上一层函数的rbp寄存器。

![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)

图1 函数栈帧的结构  

如果编译内核时打开配置宏CONFIG_UNWINDER_GUESS，那么使用猜测的方法进行栈回溯，实现的原理是：从栈顶到栈底依次读取数据，虚拟地址必须是8的整数倍，数据长度是8，如果数据属于代码段的虚拟地址范围，就有可能是保存在栈里面的返回地址。这种方法不可靠，如果某个局部变量的值在代码段的虚拟地址范围以内，会出现误判。

  

x86_64架构的函数show_trace_log_lvl()实现栈回溯，代码如下。

```
dump_stack() -> __dump_stack() -> show_stack()-> show_trace_log_lvl()
```

栈回溯的算法如下。

（1）从栈指针sp向栈底方向扫描栈，每次读取一个8字节数据，如果数据属于代码段的虚拟地址范围，那么停止扫描。

（2）使用栈回溯法获取栈里面保存返回地址的位置。如果选择猜测回溯法，那么获取栈里面保存返回地址的位置，总是返回空指针。

（3）如果第1步找到指令地址的位置正好是栈回溯法获取的保存返回地址的位置，那么第1步找到的指令地址是可靠的，否则是不可靠的（打印函数名称的时候会在前面添加问号）。

（4）如果第1步找到的指令地址是不可靠的，那么回到第1步继续扫描。

（5）使用栈回溯法获取下一个栈帧，把sp设置为下一个栈帧的结束位置，然后回到第1步继续扫描。

  

编译内核的时候，如果选择猜测回溯法，那么打印的函数调用链中所有函数名称的前面带有“?”；如果选择帧指针回溯法或者ORC回溯法，那么打印的函数调用链中只有部分函数名称的前面带有“?”。为了提高函数调用链的可读性，应该选择帧指针回溯法或者ORC回溯法。

Linux内核31

x86_64架构1

Linux内核 · 目录

下一篇家务处理器

阅读 1090

​