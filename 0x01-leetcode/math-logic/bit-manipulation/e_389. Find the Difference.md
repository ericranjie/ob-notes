Given two strings  _s_  and  _t_  which consist of only lowercase letters.

String  _t_  is generated by random shuffling string  _s_  and then add one more letter at a random position.

Find the letter that was added in  _t_.

Example:

```cpp
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
```

这道题给了我们两个字符串s和t，t是在s的任意一个地方加上了一个字符，让我们找出新加上的那个字符。这道题确实不是一道难题，首先第一反应的方法就是用哈希表来建立字符和个数之间的映射，如果在遍历t的时候某个映射值小于0了，那么返回该字符即可，参见代码如下：

解法一：

```cpp
class Solution {
public:
    char findTheDifference(string s, string t) {
        unordered_map<char, int> m;
        for (char c : s) ++m[c];
        for (char c : t) {
            if (--m[c] < 0) return c;
        }
        return 0;
    }
};
```

我们也可以使用位操作Bit Manipulation来做，利用异或的性质，相同位返回0，这样相同的字符都抵消了，剩下的就是后加的那个字符，参见代码如下：

解法二：

```cpp
class Solution {
public:
    char findTheDifference(string s, string t) {
        char res = 0;
        for (char c : s) res ^= c;
        for (char c : t) res ^= c;
        return res;
    }
};
```

我们也可以直接用加和减，相同的字符一减一加也抵消了，剩下的就是后加的那个字符，参见代码如下：

解法三：

```cpp
class Solution {
public:
    char findTheDifference(string s, string t) {
        char res = 0;
        for (char c : s) res -= c;
        for (char c : t) res += c;
        return res;
    }
};
```

下面这种方法是史蒂芬大神提出来的，利用了STL的accumulate函数，实际上是上面解法二的改写，一行就写完了真是丧心病狂啊，参见代码如下：

解法四：

```cpp
class Solution {
 public:
  char findTheDifference(string s, string t) {
    return accumulate(begin(s), end(s += t), 0, bit_xor<int>());
  }
};
```

参考资料：

[https://discuss.leetcode.com/topic/55987/java-c-1-liner](https://discuss.leetcode.com/topic/55987/java-c-1-liner)

[https://discuss.leetcode.com/topic/55960/two-java-solutions-using-xor-sum](https://discuss.leetcode.com/topic/55960/two-java-solutions-using-xor-sum)

[https://discuss.leetcode.com/topic/55912/java-solution-using-bit-manipulation](https://discuss.leetcode.com/topic/55912/java-solution-using-bit-manipulation)

[LeetCode All in One 题目讲解汇总(持续更新中...)](http://www.cnblogs.com/grandyang/p/4606334.html)